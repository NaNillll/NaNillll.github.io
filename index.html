<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta name="google-site-verification" content="kWcVT9oyylmyb6DohoXWge7VpBUZQVIptcOSS5Gr9wc" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="The Grimoire of NaNillll">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="The Grimoire of NaNillll">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>The Grimoire of NaNillll</title>
  








<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">The Grimoire of NaNillll</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/10/ComputerNetwork5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/10/ComputerNetwork5/" itemprop="url">运输层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-10T08:08:06+08:00">
                2021-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.5k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>传输层提供了主机应用程序进程之间的端到端的服务。实现了分用与复用。进行了报文差错计算。</p>
<p>只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 </p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\1.png" alt="image-20210310081042765"></p>

<p>在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。即复用 (multiplexing)和分用 (demultiplexing)。</p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\2.png" alt="image-20210310081225873"></p>

<p>根据应用程序的不同需求，运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP 。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 </p>
<h2 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h2><p>(1) 用户数据报协议 UDP (User Datagram Protocol)，提供无连接服务。在传送数据之前不需要先建立连接。传送的数据单位协议是 UDP 报文。对方的运输层在收到 UDP 报文后，不需要给出任何确认。<br>(2) 传输控制协议 TCP (Transmission Control Protocol)，提供面向连接的服务。<br>传送的数据单位协议是 TCP 报文段 (segment)。<br>TCP 不提供广播或多播服务。</p>
<p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。</p>
<h2 id="TCP-IP-运输层端口"><a href="#TCP-IP-运输层端口" class="headerlink" title="TCP/IP 运输层端口"></a>TCP/IP 运输层端口</h2><p>端口用一个 16 位端口号进行标志。端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在互联网中，不同计算机的相同端口号是没有联系的。</p>
<p>因此两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。</p>
<p>(1) 服务器端使用的端口号<br>熟知端口，数值一般为 0~1023，应用层协议在服务器端的默认端口号，客户端进程的端口号是客户端进程任意临时指定的<br>登记端口号，数值为 1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。<br>(2) 客户端使用的端口号<br>又称为短暂端口号，数值为 49152~65535，留给客户进程选择暂时使用。<br>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 </p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\3.png" alt="image-20210310081924823"></p>

<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能：复用和分用的功能；差错检测的功能</p>
<p>UDP 的主要特点 ：</p>
<ul>
<li>(1) UDP 是无连接的，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。也无连接状态。</li>
<li>(2) UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li>
<li>(3) UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。因此应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率</li>
<li>(4) UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 </li>
<li>(5) UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>(6) UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li>
</ul>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\4.png" alt="image-20210310082646269"></p>
<p>伪首部只是为了计算校验和</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 是面向连接的运输层协议。每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。<br>TCP 提供可靠交付的服务。<br>TCP 提供全双工通信。<br>面向字节流<br>TCP 中的“流”(stream)指的是流入或流出进程的字节序列。<br>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</p>
<p>TCP与网络虚电路的区别在于，TCP报文段在传输层抽象的逻辑信道中传输，路由器不可见；而虚电路经过的交换节点都必须保存虚电路的状态信息，如果使用了虚电路，就无法提供无连接服务</p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\5.png" alt="image-20210310083344105"></p>
<p>TCP 不关心应用进程一次把多长的报文发送到 TCP 缓存。TCP 对连续的字节流进行分段，形成 TCP 报文段。TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 </p>
<p>TCP 连接的端点叫做套接字 (socket) 或插口。端口号拼接到 IP 地址即构成了套接字。每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。</p>
<h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\7.png" alt="image-20210310091000730"></p>
<h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\6.png" alt="image-20210310083731050"></p>
<h4 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h4><p>B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。<br>A 为每一个已发送的分组都设置了一个超时计时器。A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。</p>
<p>若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。<br>假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：<br>第一，丢弃这个重复的分组 M1，不向上层交付。<br>第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认</p>
<p>若传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。<br>A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。<br>B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。</p>
<h3 id="自动重传请求-ARQ"><a href="#自动重传请求-ARQ" class="headerlink" title="自动重传请求 ARQ"></a>自动重传请求 ARQ</h3><p>自动重传请求 ARQ  (Automatic Repeat reQuest)。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>之前的停止等待协议属于自动重传请求ARQ</p>
<h3 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h3><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。<br>流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。</p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\8.png" alt="image-20210310091136698"></p>

<h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h3><p>发送方维持发送窗口，窗口的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。<br>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p>
<p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。优点：容易实现，即使确认丢失也不必重传。缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<p>这种协议又称为回退N（Go-back-N）</p>
<h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p>一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。<br>TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。</p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\9.png" alt="image-20210310091523302"></p>
<p>序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 </p>
<p>确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 </p>
<p>窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</p>
<h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\10.png" alt="image-20210310091818706"></p>
<p>为了选择重传时间，TCP采用了自适应算法: </p>
<p>新的RTTS  = (1-<script type="math/tex">\alpha</script>) <em> (旧的RTTS) +<script type="math/tex">\alpha</script></em> (新的RTT样本)                           </p>
<p>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就重新计算一次</p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\11.png" alt="image-20210310093156162"></p>
<p>因此使用修正的 Karn 算法 ，报文段每重传一次，就把 RTT 增大一些，一般将RTT修正为之前的两倍</p>
<h3 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h3><p>若接受方接受到的数据字节流序号不连续且缺少某些序号，如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。</p>
<p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。<br>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。</p>
<h2 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h2><p>流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 </p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\12.png" alt="image-20210310102631435"></p>
<p>这可能发生死锁：B 向 A 发送了零窗口的报文段。之后B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p>
<p>为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。若窗口不是零，则死锁的僵局就可以打破了。 </p>
<p>可以用不同的机制来控制 TCP 报文段的发送时机:</p>
<p>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。<br>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push)操作。<br>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段发送出去。</p>
<h2 id="发送与接受方的传输策略"><a href="#发送与接受方的传输策略" class="headerlink" title="发送与接受方的传输策略"></a>发送与接受方的传输策略</h2><p>若发送方 TCP 每次接收到一字节的数据后就发送，这样，发送一个字节需要形成 41 字节长的 IP 数据报。若接收方确认，就需回送一个ACK。效率很低。会造成效率较低，可使用Nagle算法</p>
<p>Nagle算法：</p>
<p>若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。<br>当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。<br>只有在收到对前一个报文段的确认后才继续发送下一个报文段。<br>当到达的数据已达到报文段的最大长度时，就立即发送。</p>
<p>这样可以降低ACK次数，同时降低重传导致的效率下降</p>
<p>若接收方的应用进程每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。效果</p>
<p>解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。</p>
<h2 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h2><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。</p>
<p>增大资源不一定解决拥塞：例如增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞。</p>
<h3 id="拥塞控制与流量控制"><a href="#拥塞控制与流量控制" class="headerlink" title="拥塞控制与流量控制"></a>拥塞控制与流量控制</h3><p>拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 </p>
<p>而流量控制往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）。所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\13.png" alt="image-20210310104619646"></p>
<h3 id="开环控制和闭环控制"><a href="#开环控制和闭环控制" class="headerlink" title="开环控制和闭环控制"></a>开环控制和闭环控制</h3><p>开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。<br>闭环控制方法是基于反馈环路的概念。属于闭环控制的有以下几种措施：<br>(1) 监测网络系统以便检测到拥塞在何时、何处发生。<br>(2) 将拥塞发生的信息传送到可采取行动的地方。<br>(3) 调整网络系统的运行以解决出现的问题。</p>
<h3 id="拥塞的指标"><a href="#拥塞的指标" class="headerlink" title="拥塞的指标"></a>拥塞的指标</h3><p>主要指标有：<br>由于缺少缓存空间而被丢弃的分组的百分数；<br>平均队列长度；<br>超时重传的分组数；<br>平均分组时延；<br>分组时延的标准差，等等。</p>
<h3 id="TCP-的拥塞控制方法"><a href="#TCP-的拥塞控制方法" class="headerlink" title="TCP 的拥塞控制方法"></a>TCP 的拥塞控制方法</h3><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。<br>TCP发送方维持一个拥塞窗口 CWND (Congestion Window)<br>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<br>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。<br>所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：min(公告窗口值，拥塞窗口值)</p>
<h3 id="判断拥塞"><a href="#判断拥塞" class="headerlink" title="判断拥塞"></a>判断拥塞</h3><p>重传定时器超时：现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于 1 %）。只要出现了超时，就可以猜想网络出现了拥塞。<br>收到三个相同（重复）的 ACK：个别报文段会在网络中丢失，预示可能会出现拥塞（实际未发生拥塞），因此可以尽快采取控制措施，避免拥塞。</p>
<h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p>慢开始 ：由小到大逐渐增大拥塞窗口数值。初始拥塞窗口 cwnd 不超过2至4个发送方的最大报文段SMSS的数值。在每收到一个对新的报文段的确认后（一个传输轮次 transmission round），可以把拥塞窗口增加，一般是加倍，直到到达慢开始门限值ssthresh </p>
<p>一个传输轮次 (transmission round)，也即往返时间RTT。例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。</p>
<p>拥塞避免阶段：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就执行慢开始算法</p>
![image-20210310105641866](D:\blog\blog\source\_posts\ComputerNetwork5\14.png)

如上图，当拥塞窗口 cwnd = 24 时，网络出现了超时（图中的点2），发送方判断为网络拥塞。于是调整门限值 ssthresh = cwnd / 2 = 12，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。

快重传算法：发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不会误认为出现了网络拥塞。因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法。

因此，如上图点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值ssthresh = cwnd / 2 = 8，同时设置拥塞窗口cwnd = ssthresh = 8，并开始执行拥塞避免算法。


<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\15.png" alt="image-20210310110201209"></p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\16.png" alt="image-20210310110525642"></p>

<h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><h3 id="运输连接"><a href="#运输连接" class="headerlink" title="运输连接"></a>运输连接</h3><p>TCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)，被动等待连接建立的应用进程叫做服务器(server)。</p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\17.png" alt="image-20210310110927241"></p>
<p>三次握手：</p>
<p>A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</p>
<p>B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x +1，自己选择的序号 seq = y。</p>
<p>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。A 的 TCP 通知上层应用进程，连接已经建立。B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程TCP 连接已经建立。</p>
<h3 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h3><p>四报文握手</p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\18.png" alt="image-20210310111200242"></p>
<p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。</p>
<p>B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。</p>
<p>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/08/ComputerNetwork4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/08/ComputerNetwork4/" itemprop="url">网络层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-08T11:09:47+08:00">
                2021-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.3k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="网络层的两种服务"><a href="#网络层的两种服务" class="headerlink" title="网络层的两种服务"></a>网络层的两种服务</h2><p>分为虚电路与数据报服务</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\1.png" alt="image-20210308172515362"></p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\2.png" alt="image-20210308172552204"></p>


<p>网络层提供简单灵活的、无连接的、尽最大努力交付的数据报服务。将可靠网络传输交给传输层。无需建立连接。每一个分组（即 IP 数据报）独立发送。</p>
<p>这样使得网络的造价很低且灵活</p>
<h2 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h2><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有三个协议：地址解析协议 ARP(Address Resolution Protocol)网际控制报文协议 ICMP(Internet Control Message Protocol)网际组管理协议 IGMP(Internet Group Management Protocol)</p>

<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\3.png" alt="image-20210308172812821"></p>
<p>IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符（ipv4）</p>

<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\4.png" alt="image-20210308172921724"></p>
<p>点分十进制记法 </p>

<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\5.png" alt="image-20210308173017699"></p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\6.png" alt="image-20210308173125225"></p>

<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\7.png" alt="image-20210308173313667"></p>
<p>在同一个局域网上的主机或路由器的IP 地址中的网络号必须是一样的。路由器总是具有两个或两个以上的 IP 地址。路由器的每一个接口都有一个不同网络号的 IP 地址。两个路由器直接相连的接口处，可指明也可不指明 IP 地址。如指明 IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” 。</p>
<h2 id="IP-地址与硬件地址"><a href="#IP-地址与硬件地址" class="headerlink" title="IP 地址与硬件地址"></a>IP 地址与硬件地址</h2><p>硬件地址（或物理地址）是数据链路层和物理层使用的地址</p>
<p>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\8.png" alt="image-20210308173851627"></p>


<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\9.png" alt="image-20210308212359972"></p>
<p>每一个主机都设有一个 ARP 高速缓存 (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p>
<p>&lt; IP address；MAC address；TTL &gt;TTL (Time To Live)：地址映射有效时间 </p>
<p>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。<br>如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。如没有， ARP 进程在本局域网上广播发送一个 ARP 请求分组。收到 ARP 响应分组后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。ARP看到了IP地址，因此工作在网络层</p>
<p>调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的.</p>
<p>具体来说：</p>
<p>发送方是主机/路由器，发送到本网络另一个主机，只需直接查询ARP；发送到另一网络主机，用ARP找到本网络上一个路由器的地址，然后剩下工作让路由器处理</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\10.png" alt="image-20210308215026552"></p>

<p>IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。因为增加开销，所以实际上这些选项很少被使用。</p>
<p>路由表没有给分组指明到某个网络的完整路径。路由表指出，到某个网络应当先到某个路由器（即下一跳路由器）。在到达下一跳路由器后，再继续查找其路由表，直到再下一步应当到哪一个路由器。这样一步一步地查找下去，直到最后到达目的网络。</p>
<h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。<br>从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\11.png" alt="image-20210309125940012"></p>

<p>减少了 IP 地址的浪费；使网络的组织更加灵活；更便于维护和管理</p>
<p>从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码(subnet mask)可以找出 IP 地址中的子网部分。  </p>
<p>子网掩码长度＝32位。某位＝1：IP地址中的对应位为网络号和子网号。某位＝0：IP地址中的对应位为主机号</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\12.png" alt="image-20210309130210263"></p>

<p>数据报的首部并没有提供子网掩码的信息。因此分组转发的算法也必须做相应的改动</p>
<p>(1) 从收到的分组的首部提取目的 IP 地址 D。<br>(2) 先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行 (3)。<br>(3) 若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行 (4)。<br>(4) 对路由表中的每一行，将子网掩码和 D 逐位相“与”。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行 (5)。<br>(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行 (6)。<br>(6) 报告转发分组出错。</p>
<h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。</p>
<p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\13.png" alt="image-20210309130717073"></p>

<p>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 </p>
<p>差错报告报文共有 4 种 ：终点不可达；时间超过；参数问题；改变路由（重定向）</p>
<p>询问报文有2种 ：回送请求和回答报文；时间戳请求和回答报文</p>
<p>PING (Packet InterNet Groper) ：用来测试两个主机之间的连通性。 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。 </p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器是网络层设备，实现了网络模型的下三层</p>
<p>路由器的任务是连接不同的网络，完成分组转发和路由计算（包括路由表维护）</p>
<p>在同一个网络内部转发无需路由器，否则需要（连接同构网络倒是可以使用交换机）</p>
<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>不存在一种绝对的最佳路由算法。所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</p>
<ul>
<li>内部网关协议 IGP (Interior Gateway Protocol)<br>在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li>
<li>外部网关协议 EGP (External Gateway Protocol)<br>若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。  </li>
</ul>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>一般来说，路由表有4个项目：目的网络ip，子网掩码，下一跳IP地址，接口</p>
<h3 id="转发表"><a href="#转发表" class="headerlink" title="转发表"></a>转发表</h3><p>转发表是油路由表得到的，含有一个分组将发往的目的地址，以及分组的下一跳。为了减少重复的项目，可以用默认路由代替所有具有相同下一跳的项目</p>
<p>转发与路由选择的区别：转发只涉及1个路由器，把收到的IP数据报从合适的端口转发出去；路由选择涉及很多路由器，路由表是协同工作的结果</p>
<h3 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP"></a>内部网关协议 RIP</h3><p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。</p>
<p>从一个路由器到直接连接的网络的距离定义为 1。从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。RIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1。这里的“距离”实际上指的是“最短距离”。 RIP 允许一条路径最多只能包含 15 个路由器（防止环路）。“距离”的最大值为 16 时即相当于不可达。可见 RIP 只适用于小型互联网。RIP不支持子网掩码的RIP广播，因此RIP中每个网络的子网掩码必须相同</p>
<p>RIP只与相邻路由器交换信息，交换当前路由器所知道的全部信息</p>
<p>RIP默认在使用RIP的路由器之间每30秒广播一次RIP路由更新情况</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\14.png" alt="image-20210309131937214"></p>

<p>RIP协议特点：好消息传播得快，坏消息传播得慢。</p>
<h3 id="内部网关协议-OSPF"><a href="#内部网关协议-OSPF" class="headerlink" title="内部网关协议 OSPF"></a>内部网关协议 OSPF</h3><p>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。<br>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。  </p>
<p>如果到同一个网络有多条代价相同的路径，可以将通信量分配给这几条路径，形成负载平衡</p>
<p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过 200 个。  </p>
<p>OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF  协议要比距离向量协议 RIP 好得多。</p>
 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\15.png" alt="image-20210309132858732"></p>
<p>OSPF共有以下五种分组类型:</p>
<p>(1)类型1，问候(Hello)分组，用来发现和维持邻站的可达性。通常10秒就要交换一次问候分组</p>
<p>(2)类型2，数据库描述(Database DescriPtion)分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。刚开始工作时会使用，与相邻路由器交换信息</p>
<p>(3)类型3，链路状态请求(Link State Request)分组，向对方请求发送某些链路状态项目的详细信息。</p>
<p>(4)类型4，链路状态更新(Link State Update)分组，用洪泛法对全网更新链路状态</p>
<p>(5)类型5，链路状态确认(Link State Acknowledgment)分组，对链路更新分组的确认。</p>
<p>刚开始工作时，数据库描述分组-》链路状态请求分组，这样建立了全网同步的链路数据库。只要一个路由器状态变化，他就使用链路状态更新分组，其他路由器更新后发送链路状态确认分组。OSPF规定没隔一段时间就刷新一次数据库内的链路状态</p>
<h3 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h3><p>BGP 是不同自治系统的路由器之间交换路由信息的协议。 </p>
<p>边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。  </p>
<p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人” (BGP speaker) 。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的。 BGP 发言人之间要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。所有发言人都交换网络可达性的信息（即到达某个网络所要经过的一系列AS）后，各BGP发言人就可找到到达各个自治系统的较好路由</p>
<p>BGP发言人除必须运行BGP外，还必须运行该AS所用的内部网关协议，如OSPF</p>
 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\16.png" alt="image-20210309133101599"></p>
<p>BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。</p>
<p>BGP使用四种报文：</p>
<p>打开open，用来与相邻的发言人建立关系</p>
<p>更新update，用来发送某一路由的信息，以及列出要撤销的多条路由</p>
<p>keepalive，确认呢打开报文并周期性证实邻站关系</p>
<p>notification，发送检测到的差错</p>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2> 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\17.png" alt="image-20210309133544333"></p>
<p>IPv6 引进的主要变化：</p>
<p>更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。<br>扩展的地址层次结构。<br>灵活的首部格式。 IPv6 定义了许多可选的扩展首部。<br>改进的选项。 IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。<br>允许协议继续扩充。<br>支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。<br>支持资源的预分配。</p>
 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\18.png" alt="image-20210309133720614"></p>
<p>IPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并将扩展首部留给路径两端的源站和目的站的主机来处理。数据报途中经过的路由器都不处理这些扩展首部（只有一个首部例外，即逐跳选项扩展首部）。这样就大大提高了路由器的处理效率。</p>
  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\19.png" alt="image-20210309133906239"></p>
<p>IPv6 数据报的目的地址可以是以下三种基本类型地址之一：<br>(1) 单播 (unicast)：传统的点对点通信。<br>(2) 多播 (multicast)：一点对多点的通信。<br>(3) 任播 (anycast)：这是 IPv6 增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交付其中的一个，通常是距离最近的一个。 </p>
<p>IPv6 使用冒号十六进制记法(colon hexadecimal notation, 简写为colon hex)。<br>每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如：<br>68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF<br>在十六进制记法中，允许把数字前面的0省略。例如把0000中的前三个0省略，写成1个0。</p>
<p>冒号十六进制记法可以允许零压缩 (zero compression)，即一连串连续的零可以为一对冒号所取代。FF05:0:0:0:0:0:0:B3  可压缩为FF05::B3</p>
<h3 id="从-IPv4-向-IPv6-过渡"><a href="#从-IPv4-向-IPv6-过渡" class="headerlink" title="从 IPv4 向 IPv6 过渡"></a>从 IPv4 向 IPv6 过渡</h3><p>IPv6 过渡只能采用逐步演进的办法，同时，还必须使新安装的 IPv6 系统能够向后兼容：IPv6 系统必须能够接收和转发 IPv4 分组，并且能够为 IPv4 分组选择路由</p>
<h4 id="双协议栈"><a href="#双协议栈" class="headerlink" title="双协议栈"></a>双协议栈</h4>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\20.png" alt="image-20210309135026264"></p>
<h4 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h4>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\21.png" alt="image-20210309135157722"></p>
<p>IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6</p>
  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\22.png" alt="image-20210309135302904"></p>
<h2 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h2>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\23.png" alt="image-20210309135525175"></p>
<p>IP 多播所传送的分组需要使用多播 IP 地址。多播组的标识符就是 IP 地址中的 D 类地址</p>
<p>多播数据报和一般的 IP 数据报的区别就是它使用 D 类 IP 地址作为目的地址，并且首部中的协议字段值是2，表明使用网际组管理协议 IGMP。多播数据报也是“尽最大努力交付”，不保证一定能够交付多播组内的所有成员。对多播数据报不产生 ICMP 差错报文。因此，若在 PING 命令后面键入多播地址，将永远不会收到响应。</p>
<h3 id="网际组管理协议-IGMP"><a href="#网际组管理协议-IGMP" class="headerlink" title="网际组管理协议 IGMP"></a>网际组管理协议 IGMP</h3><p>IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机参加或退出了某个多播组。</p>
<p>IGMP 可分为两个阶段 </p>
<p>第一阶段：加入多播组。<br>当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。<br>本地的多播路由器收到 IGMP 报文后，将组成员关系转发给互联网上的其他多播路由器。</p>
<p>第二阶段：探询组成员变化情况。<br>因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。<br>只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。<br>但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。</p>
  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\24.png" alt="image-20210309140942875"></p>
<p>一个多播组中的成员是动态变化的，随时会有主机加入或离开这个多播组。多播路由选择实际上就是要找出以源主机为根结点的多播转发树。</p>
<p>多播路由选择协议在转发多播数据报时使用三种方法</p>
<h4 id="洪泛与剪除"><a href="#洪泛与剪除" class="headerlink" title="洪泛与剪除"></a>洪泛与剪除</h4><p>这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。</p>
<p>一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。为了避免兜圈子，采用反向路径广播策略。 先检查它是否是从源点经最短路径传送来的。若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就丢弃而不转发。</p>
<p>多播转发树上的路由器发现它的下游树枝已没有多播组的成员，就把它和下游树枝一起剪除。</p>
<h4 id="隧道技术-1"><a href="#隧道技术-1" class="headerlink" title="隧道技术"></a>隧道技术</h4>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\25.png" alt="image-20210309141337873"></p>
<h4 id="基于核心的发现技术"><a href="#基于核心的发现技术" class="headerlink" title="基于核心的发现技术"></a>基于核心的发现技术</h4><p>这种方法是对每一个多播组 G 指定一个核心(core) 路由器，给出它的 IP 单播地址。<br>核心路由器创建出对应于多播组 G 的转发树。 </p>
<h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。</p>
<p>利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网VPN (Virtual Private Network)。“专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。</p>
 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\26.png" alt="image-20210309145134833"></p>
<h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>装有 NAT 软件的路由器叫作 NAT路由器，它至少有一个有效的外部全球IP地址。<br>所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接。  </p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网 (plug-and-play networking) 的机制。<br>这种机制允许一台计算机加入新的网络和获取IP 地址而不用手工参与。</p>
<p>DHCP 中继代理以单播方式转发发现报文 </p>
 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\27.png" alt="image-20210310163732725"></p>
<p>DHCP 协议是基于UDP层之上的应用，dhcp使用udp携带报文，udp封装在ip数据包中发送</p>
<p><a href="http://www.023wg.com/message/message/cd_feature_dhcp_message_format.html" target="_blank" rel="noopener">http://www.023wg.com/message/message/cd_feature_dhcp_message_format.html</a></p>
<p>DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。<br>租用期的数值应由 DHCP 服务器自己决定。<br>DHCP 客户也可在自己发送的报文中（例如，发现报文）提出对租用期的要求。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/07/ComputerNetwork3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/07/ComputerNetwork3/" itemprop="url">数据链路层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-07T15:07:12+08:00">
                2021-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据链路层的主要作用是如何将数据可靠地传输到相邻节点</p>
<p>数据链路层使用的信道主要有以下两种类型:</p>
<p>点对点信道。这种信道使用一对一的点对点通信方式。<br>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。 </p>
<h2 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h2><p>物理链路 (link) 是一条点到点的物理线路段，中间没有任何其他的交换结点。除了物理线路外，还必须有通信协议来进行传输控制。软件+硬件形成了数据链路</p>
<p>目前最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能</p>
<h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a><strong>三个基本问题</strong></h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a><strong>封装成帧</strong></h3><p>封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\4.png" alt="image-20210307171441510"></p>

<p>当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符。控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT (End Of Transmission) 表示帧的结束。</p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a><strong>透明传输</strong></h3><p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\5.png" alt="image-20210307171643848"></p>

<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a><strong>差错检测</strong></h3><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER </p>
<p>误码率与信噪比有很大的关系</p>
<h4 id="循环冗余检验-CRC"><a href="#循环冗余检验-CRC" class="headerlink" title="循环冗余检验 CRC"></a><strong>循环冗余检验</strong> <strong>CRC</strong></h4><p>假设待传送的一组数据 M ，k位，冗余码n位。 M 后面添加 n 个 0。得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，R 是 n 位 。 将余数 R 作为冗余码拼接在数据 M 后面发送出去。</p>
<h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><p>不但要提醒出现问题，最好能够定位</p>
<p>常见方法是海明码</p>
<p><a href="https://www.cnblogs.com/godoforange/p/12003676.html" target="_blank" rel="noopener">https://www.cnblogs.com/godoforange/p/12003676.html</a></p>
<h2 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h2><p>之所以分组，是为了在出错时只需要重发出错的帧，提高效率</p>
<p>组帧时需要首尾都有，因为网络中信息是以帧为最小单位进行传输的。而分组（IP数据报）包含在帧的数据部分内，因此无需尾部定界</p>
<p>为了实现组帧分界，有以下方法：</p>
<ul>
<li>字符计数法：帧头部表明帧内字符数</li>
<li>字符填充：见下文</li>
<li>零比特填充：见下文</li>
<li>违规编码：采用违规电平对</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><p>每次只允许一帧，然后下一帧</p>
<h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><h4 id="后退N帧"><a href="#后退N帧" class="headerlink" title="后退N帧"></a>后退N帧</h4><p>发送窗口不为1，接受窗口为1，每次收到确认帧，发送窗口前移一帧</p>
<p>确认帧不一定连续，可以收到几个帧之后发送最后的接受帧号</p>
<p>接受端只按序接受，如果中间隔帧即使收到的顺序正确也会全部丢弃</p>
<p>不一定优于停止-等待协议</p>
<h4 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h4><p>发送窗口与接受窗口均不为1</p>
<p>如果计时器超时或者接收到否定帧NAK都会重传</p>
<p>为了保证接受方移动后新旧窗口没有重叠，如果采用n比特对帧编号，需要：接收窗口+发送窗口&lt;=<script type="math/tex">2^n</script>。不然会出错（可以考虑n=3，接受窗口为1的情况，重传的8个帧与新的8个帧编号相同）</p>
<p>一般情况下，接受与发送窗口大小相同</p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>局域网的协议一般在数据链路层和物理层，而广域网在网络层</p>
<p>PPP与HDLC是常见的两种广域网数据链路层控制协议</p>
<h3 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h3><p><a href="https://www.cnblogs.com/chaguang/p/8097967.html" target="_blank" rel="noopener">https://www.cnblogs.com/chaguang/p/8097967.html</a></p>
<p>应用在直接相连两个节点的链路上</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\6.png" alt="image-20210307172929508"></p>

<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\17.png" alt="image-20210307201128536"></p>

<p>PPP协议是一种在串行链路上传输IP数据包的一种方法，是一个协议的集合，不是单一的协议，支持建立链路的链路控制协议LCP以及一系列的NCP</p>
<p>PPP帧如下所示</p>

<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\7.png" alt="image-20210307173038517"></p>
<p>为实现透明传输，当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充；当 PPP 用在异步传输时，就使用一种特殊的字符填充法。 </p>

<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\8.png" alt="image-20210307173358468"></p>

<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\9.png" alt="image-20210307174107549"></p>

<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><p>高级链路层协议（HDLC）面向比特（PPP面向字节），不依赖于任何一种字符编码集；数据报文可透明传输，用0比特插入法；全双工；采用CRC校验</p>
<p>适用于非平衡配置（一个主站控制其他所有）与平衡配置（链路两端是平等的复合站）</p>
<p>HDLC有三种站：主站（控制链路，发出 命令帧）；从站（受控于主站，发出 响应帧）；复合站</p>
<p>HDLC有三种数据操作方式：</p>
<ul>
<li>正常响应：主站命令，从站相应</li>
<li>异步平衡：每个复合站都可以进行数据传输</li>
<li>异步相应：从站未收到主站命令，也可以相应</li>
</ul>
<p><a href="http://www.023wg.com/message/message/cd_feature_hdlc_frame.html" target="_blank" rel="noopener">http://www.023wg.com/message/message/cd_feature_hdlc_frame.html</a></p>
<h2 id="介质控制访问"><a href="#介质控制访问" class="headerlink" title="介质控制访问"></a>介质控制访问</h2><p>隔离来自同一信道的其他节点的信号</p>
<h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><p>多路复用，比如频分/时分/波分/码分 复用</p>
<h3 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h3><p>既不共享时间，也不共享空间</p>
<p>有ALOHA/CSMA等协议</p>
<h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><p>纯ALOHA：不检测直接发送，如果没有收到确认说明冲突了，重新发送</p>
<p>时隙ALOHA：只有时隙的开始才能够发送，时隙的程度使得帧可以正好发送完毕</p>
<h3 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h3><p>令牌传递</p>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网最重要的特征就是具有广播功能</p>
<p>局域网主要的特点有：所有站点平等，能够广播和组播，较低时延就较高的总带宽</p>
<p>数据链路层可以拆成逻辑链路控制子层LLC与媒体介入控制子层MAC，后者提供对物理层的统一访问接口；前者为网络层提供服务接口</p>
<p>三种特殊的局域网：</p>
<ul>
<li>以太网，目前应用最普遍的局域网技术，逻辑拓扑为总线形，实际可以为星形或拓展星形</li>
<li>令牌网，逻辑环形，实际星形</li>
<li>光纤分布数字接口FDDI，逻辑环形，实际双环结构</li>
</ul>
<p>IEEE802.3局域网可以简称为以太网，它与DIX Ethernet V2标准差别微小</p>
<p>计算机与外界的连接通过网络接口板（网卡），装有处理器和控制器，实现帧的控制与交换等，具有全球唯一的一个代码MAC地址</p>
<p>IEEE802.11是无线局域网的一系列协议，制定了MAC层协议，采用CSMA/CA协议进行介质访问控制。在无线局域网中发送过程中碰撞也要继续传递直到帧传递完全；有线会直接停止</p>
<p>无线局域网可以分为</p>
<ul>
<li>固定基础设施无线局域网：无线局域网的最小构建是基本服务集（BBS），所有的站在本BBS内都可以直接通信，对站外需要经过接入点（AP），AP作用类似网桥。一个BBS可以是孤立的，也可以通过AP连接到主干分配系统DS再接入另一个基本服务集，形成扩展的服务集。也可以通过门桥接入其他类型的无线局域网</li>
<li>无固定基础设施无线局域网自组织网络：没有AP，各移动站状态平等，中间节点都为转发节点且有路由器功能</li>
</ul>
<h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a><strong>CSMA/CD</strong> <strong>协议</strong></h3><p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\10.png" alt="image-20210307175016131"></p>

<p>CSMA/CD 含义：载波监听多点接入 / 碰撞检测  </p>
<p>一般用于总线型以太网</p>
<p>协议要点：</p>
<p>(1) 准备发送。<br>(2) 检测信道。若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。<br>(3) 检查碰撞。在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里只有两种可能性：<br>①发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到 (1)。<br>②发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 (2)，继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\11.png" alt="image-20210307175435098"></p>

<p>1990年 IEEE 制定出星形以太网 10（速率10M/s）BASE（基带）-T（双绞线） 的标准 802.3i，之后以太网也就在局域网中占据了统治地位</p>
<p>集线器/路由器/交换机与冲突域/广播域： <a href="https://blog.csdn.net/gui951753/article/details/79402528" target="_blank" rel="noopener">https://blog.csdn.net/gui951753/article/details/79402528</a></p>
<p>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。<br>集线器很像一个多接口的转发器</p>
<p>多个站在以太网工作时可能会发生碰撞。假设$\zeta$是以太网单程端到端传播时延。则争用期（冲突窗口期）长度为 2$\zeta$，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。 </p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\12.png" alt="image-20210307181219914"></p>

<p>如果发送端在2$\zeta$内没有收到干扰信号，那么之后也不会收到干扰信号，因为并没有其他端口回复干扰。因此最小帧长为2$\zeta$*发送速率。如果收到一个帧长更小的帧，说明没有传完就被打断，直接丢弃</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\13.png" alt="image-20210307181713440"></p>

<h3 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h3><p>用于无线区域网，无法碰撞检测</p>
<p>修改CSMA/CD协议，将碰撞检测改为碰撞避免。不仅要等待一个时间间隔，还要竞争窗口并随机退避时间。当检测到信道空闲且数据帧是要发送的第一个数据帧时才会发送</p>
<p>除此外还使用预约信道（通知其他站点自己传输的时长），ACK帧（发给发送方，如果收不到就要重传），RTS/CTS帧</p>
<h3 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h3><p>在局域网中，硬件地址又称为物理地址，或 MAC 地址。 MAC地址是局域网通信设备或端口的唯一标识符。 </p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\14.png" alt="image-20210307182034508"></p>

<p>IEEE规定地址字段的第一字节的最低位为 I/G 位。I/G 表示 Individual / Group。当 I/G位=0 时，地址字段表示一个单站地址。当 I/G位=1 时，表示组地址，用来进行多播（以前曾译为组播）。所有 48 位都为 1 时，为广播地址。只能作为目的地址使用。</p>
<p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址。如果是传到本站的收下，否则丢弃</p>
<p>最常用的 MAC 帧是以太网 V2 的格式</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\15.png" alt="image-20210307182249428"></p>

<p>类型字段用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\16.png" alt="image-20210307200703676"></p>

<h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><p>使用集线器扩展。但是碰撞域也被增大了，且如果不同的碰撞域数据率不同，就无法连接起来</p>
<h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a><strong>在数据链路层扩展以太网</strong></h3><p>扩展以太网早期使用网桥，现在使用以太网交换机</p>
<p>网桥根据 MAC 帧的目的地址对收到的帧进行转发和过滤。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。 </p>
<p>根据路由选择算法不同，可以将网桥分为：</p>
<ul>
<li>透明网桥，通过自学习法</li>
<li>源路由网桥，路由选择由源站控制，原站发出发现帧，传递直到目的站，目的站发送应答帧，通过源路径返回，记录途径的网桥，然后源站就获得路径并选出最佳路由（往返时间最短）。之后再发送时必须要携带这一路由信息</li>
</ul>
<p>以太网交换机实质上就是一个多接口的网桥，每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。以太网交换机具有并行性，可以无碰撞地传输数据，并不会扩大碰撞域。不但隔离了冲突域，还通过VLAN隔离了广播域</p>
<p>以太网交换机的接口有存储器，能在输出端口繁忙时把到来的帧进行缓存。以太网交换机是一种即插即用设备，其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。以太网交换机使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。</p>
<p>目前以太网有直通（只检查目的地址，直接发送，不能支持不同速率的端口的交换）和存储转发（先缓存再检查帧是否出错，出错便丢弃，支持不同速率的端口的交换）两种交换模式</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\18.png" alt="image-20210307203457951"></p>

<p>交换机收到一帧后先进行自学习。查找交换表中与收到帧的源地址有无相匹配的项目。<br>如没有，就在交换表中增加一个项目（源地址、进入的接口和有效时间）。<br>如有，则把原有的项目进行更新（进入的接口或有效时间）。<br>转发帧。查找交换表中与收到帧的目的地址有无相匹配的项目。<br>如没有，则向所有其他接口（进入的接口除外）转发。<br>如有，则按交换表中给出的接口进行转发。<br>若交换表中给出的接口就是该帧进入交换机的接口，则应丢弃这个帧（因为这时不需要经过交换机进行转发）</p>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</p>
<p>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为 VLAN 标记 (tag)，用来指明发送该帧的计算机属于哪一个虚拟局域网。插入 VLAN 标记得出的帧称为 802.1Q 帧 或 带标记的以太网帧。</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\ComputerNetwork3\19.png" alt="image-20210307204031653"></p>

<p>如上图，B1广播时，只有B2和B3会接收到，其余成员不会</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/07/computerNetwork2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/07/computerNetwork2/" itemprop="url">网络层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-07T13:47:38+08:00">
                2021-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据流</p>
<p>信号具体怎样传递，存在着不同方式，其中需要经过调制等信号处理手段。传输时可能是数字信号，也可能是模拟信号。前者为离散信号，后者为连续信号。二者通过采样量化等手段可以相互转化</p>
<h2 id="通信的一些定义"><a href="#通信的一些定义" class="headerlink" title="通信的一些定义"></a>通信的一些定义</h2><p>码元是用一个固定时长（码元宽度）的信号波形表示一个k进制的数字，表示离散值的基本波形。比如二进制编码时就只有两种码元</p>
<p>码元传递效率即单位时间内能够传递码元的个数，也即脉冲个数活信号变化的次数，单位是波特，信息传递效率即k*码元传递效率</p>
<p>信道 —— 一般用来表示向某一个方向传送信息的媒体</p>
<p>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互</p>
<p>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)</p>
<p>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息</p>
<p>基带信号（即基本频带信号）—— 来自信源的信号，一般为低频不方便传输。通过调制时不同的载波，可以调制到不同的频段</p>
<h2 id="数字数据转化为数字信号"><a href="#数字数据转化为数字信号" class="headerlink" title="数字数据转化为数字信号"></a>数字数据转化为数字信号</h2><p>不归零制：不归零制：正电平代表 1，负电平代表 0。<br>归零制：正脉冲代表 1，负脉冲代表 0。<br>曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。<br>差分曼彻斯特编码：若为1，则前半电位与上一个码元后半电位相同，0则反之</p>
<p><img src="/03/07/computerNetwork2/blog\blog\source\_posts\computerNetwork2\1.png" alt="image-20210307140031047"></p>

<h2 id="数字数据转化为模拟信号"><a href="#数字数据转化为模拟信号" class="headerlink" title="数字数据转化为模拟信号"></a>数字数据转化为模拟信号</h2><p>基本的调制方法：调幅（AM），随数字信号调节载波振幅；调频（FM）；调相（AM）</p>

<p><img src="/03/07/computerNetwork2/blog\blog\source\_posts\computerNetwork2\2.png" alt="image-20210307140909735"></p>
<p>为了提高信息传递效率，可以采用混合调制的方法，比如正交振幅调制</p>
<h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p>信号传递的过程中会出现失真，也即信道内部存在噪声S，设信号为N，信噪比(dB) = 10 log10(S/N)    (dB) </p>
<p><img src="/03/07/computerNetwork2/blog\blog\source\_posts\computerNetwork2\3.png" alt="image-20210307142040963"></p>

<p>因此若信噪比或带宽无限大时，理想传输速率无限大</p>
<h2 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h2><p>在没有噪声的情况下，因为码间干扰，理想低通信道的极限数据传输率为2WlogV，V为离散码元种类总数，W为低通信道的带宽</p>
<p>并不是香农定理的极限形式，只是从两个角度进行了分析</p>
<h2 id="物理层下的传输媒体"><a href="#物理层下的传输媒体" class="headerlink" title="物理层下的传输媒体"></a>物理层下的传输媒体</h2><p>这些传输媒体不属于物理层</p>
<p>可分为导引型（光缆）与非导引型（电磁波）</p>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a><strong>信道</strong>复用技术</h2><p>频分复用</p>
<p>时分复用</p>
<p>码分复用：每一个比特时间（发送1bit需要的时间）划分为 m 个短的间隔，称为码片，每个站被指派一个唯一的 m bit 码片序列。这样每个站点的发送数据率/频带宽度变成之前的m倍。码片之间必须各不相同且正交</p>
<h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><h3 id="ADSL-技术"><a href="#ADSL-技术" class="headerlink" title="ADSL 技术"></a>ADSL 技术</h3><p>用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。电话只使用了低频，这样高频就可以用来上网，带宽不对称</p>
<h3 id="DMT-技术"><a href="#DMT-技术" class="headerlink" title="DMT 技术"></a>DMT 技术</h3><p>同样是电话线，频分复用</p>
<h3 id="。。。"><a href="#。。。" class="headerlink" title="。。。"></a>。。。</h3><h2 id="电路交换-报文交换-分组交换"><a href="#电路交换-报文交换-分组交换" class="headerlink" title="电路交换/报文交换/分组交换"></a>电路交换/报文交换/分组交换</h2><p>电路交换：数据传输前两点间建立专用的通信道路，直到通信结束后释放</p>
<p>报文交换：无需链接，动态分配道路，数据交换的单位是报文，交换时存储转发</p>
<p>存储转发：以太网交换机的控制器先将输入端口到来的数据包缓存起来，先检查数据包是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。正因如此，存储转发方式在数据处理时延时大，这是它的不足，但是它可以对进入交换机的数据包进行错误检测，并且能支持不同速度的输入/输出端口间的交换，可有效地改善网络性能。它的另一优点就是这种交换方式支持不同速度端口间的转换，保持高速端口和低速端口间协同工作。实现的办法是将10Mbps低速包存储起来，再通过100Mbps速率转发到端口上。</p>
<p>分组交换：报文分组后的报文交换</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/07/ComputerNetwork1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/07/ComputerNetwork1/" itemprop="url">计算机网络概况</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-07T10:31:08+08:00">
                2021-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><strong>数据的传送速率</strong>，它也称为数据率(data rate)或比特率 (bit rate)。单位是bit/s，或 kbit/s等</p>
<p>速率往往是指额定速率或标称速率，非实际运行速率</p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>无线网络中，指<strong>信号具有的频带宽度</strong>，单位是HZ</p>
<p>有线网络中，指<strong>某通道传播数据的能力</strong>，单位是bit/s</p>
<p>前者是频域称谓，后者是时域称谓，本质是一样的。<strong>其本质是类似的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“数据率”也越高。</strong></p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a><strong>吞吐量</strong></h3><p><strong>在单位时间内通过某个网络（或信道、接口）的数据量</strong>，<strong>更经常地用于对现实世界中的网络的一种测量</strong></p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a><strong>时延</strong></h3><p><strong>是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间</strong></p>
<p>由以下几个不同的部分组成：</p>
<ol>
<li><strong>发送时延</strong></li>
<li><strong>传播时延</strong></li>
<li><strong>处理时延</strong></li>
<li><strong>排队时延</strong></li>
</ol>
<p><strong>发送时延</strong>也被成为传输时延，指的是数据帧从进入传输媒体到全部发送完毕需要的时间，等于数据帧长度/发送速率</p>
<p><strong>传播时延</strong>指的是电磁波在信道中传播所需要的时间，与信号的传播速率而不是发送速率相关</p>
<p><strong>处理时延</strong>指的是主机或者路由器处理分组（例如差错校验）花的时间</p>
<p><strong>排队时延</strong>指的是分组在路由器输入输出队列中排队等待处理所经历的时延，往往取决于网络中当时的通信量</p>
<p><img src="/03/07/ComputerNetwork1/blog\blog\source\_posts\ComputerNetwork1\1.png" alt="image-20210307105331163"></p>

<p>对于高速网络，提高的是数据的发送速率，而非传播速率</p>
<h3 id="往返时延"><a href="#往返时延" class="headerlink" title="往返时延"></a>往返时延</h3><p>发送端开始发送数据，到接收到另一端的确认信号</p>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>信道多少比例时间有信号通过的</p>
<h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p><img src="/03/07/ComputerNetwork1/blog\blog\source\_posts\ComputerNetwork1\2.png" alt="image-20210307105631056"></p>

<p>服务数据单元，SDU</p>
<p>协议控制信息，PCI</p>
<p>协议数据单元，PDU。对等层次之间传递的数据单元，物理层成为比特，链路层成为帧，网络层成为分组，传输层成为报文等</p>
<p>n-SDU+n-PCI=n-PDU=（n-1）-SDU</p>
<p>上一层只能调用临近层的接口使用下一层的服务，下一层对上一层透明</p>
<p>如果对等层在逻辑上有直接信道，就可以不经过下层直接传递</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>对等层次之间的规则</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>同一节点相邻层级之间交换信息的连接点。SAP服务访问点</p>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>下层为紧邻的上层提供功能调用，这个过程中必须进行交换一些命令，成为服务原语</p>
<ul>
<li>请求，服务用户》服务提供者</li>
<li>指示，服务提供者》服务用户</li>
<li>相应，服务用户》服务提供者，对指示的响应</li>
<li>证实，服务提供者》服务用户，对获得请求的证实</li>
</ul>
<h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><p>面向连接/无连接：前者传输时需要先建立连接，分配缓冲区，传输后需要释放；后者需要发送时直接发送，这是不可靠的</p>
<p>可靠/不可靠：后者的正确性与可靠性需要用户保障</p>
<p>有应答/无应答：接受方收到数据是否要应答，这个应答需要传输系统内部自动实现。www服务中客户端收到页面无需应答</p>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="按照分布"><a href="#按照分布" class="headerlink" title="按照分布"></a>按照分布</h3><p>广域网（WAN）</p>
<p>城域网（MAN）</p>
<p>局域网（LAN），传统上，局域网采用广播技术，而广域网采用交换技术</p>
<p>个人区域网（PAN）</p>
<h3 id="按照传输技术"><a href="#按照传输技术" class="headerlink" title="按照传输技术"></a>按照传输技术</h3><p>广播式网络，所有计算机共享一个公共信道。局域网大多采用的方式</p>
<p>点对点网络，每条物理线路连接一对计算机</p>
<p>是否采用分组存储转发与路由选择是二者的重要区别</p>
<h3 id="按照拓扑"><a href="#按照拓扑" class="headerlink" title="按照拓扑"></a>按照拓扑</h3><p>总线/星/环 形等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/01/the-limitations-of-deep-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/01/the-limitations-of-deep-learning/" itemprop="url">limitations and future of deep learning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-01T11:21:46+08:00">
                2021-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="limitations"><a href="#limitations" class="headerlink" title="limitations"></a>limitations</h1><p><a href="https://blog.keras.io/the-limitations-of-deep-learning.html" target="_blank" rel="noopener">https://blog.keras.io/the-limitations-of-deep-learning.html</a></p>
<h2 id="Deep-learning-the-geometric-view"><a href="#Deep-learning-the-geometric-view" class="headerlink" title="Deep learning: the geometric view"></a>Deep learning: the geometric view</h2><p>In deep learning, everything is a vector, i.e. everything is a <em>point</em> in a <em>geometric space</em>. </p>
<p>Together, the chain of layers of the model forms one very complex geometric transformation</p>
<p>This complex transformation attempts to maps the input space to the target space</p>
<p>A key characteristic of this geometric transformation is that it must be <em>differentiable</em>, which is required in order for us to be able to learn its parameters via gradient descent</p>
<p>总而言之，这就是将高维数据的复杂流形解压的过程，就像把一个揉皱的纸球解开弄平一样</p>
<h2 id="The-limitations-of-deep-learning"><a href="#The-limitations-of-deep-learning" class="headerlink" title="The limitations of deep learning"></a>The limitations of deep learning</h2><p>The space of applications that can be implemented with this simple strategy is nearly infinite</p>
<p> In general, anything that requires reasoning—like programming, or applying the scientific method—long-term planning, and algorithmic-like data manipulation, is out of reach for deep learning models— Even learning a sorting algorithm with a deep neural network is tremendously difficult.</p>
<p>This is because a deep learning model is “just” <em>a chain of simple, continuous geometric transformations</em> mapping one vector space into another</p>
<p>most programs cannot be expressed as deep learning models</p>
<p>most of the programs that one may wish to learn cannot be expressed as a continuous geometric morphing of a data manifold</p>
<h2 id="The-risk-of-anthropomorphizing-machine-learning-models"><a href="#The-risk-of-anthropomorphizing-machine-learning-models" class="headerlink" title="The risk of anthropomorphizing machine learning models"></a>The risk of anthropomorphizing machine learning models</h2><p>One very real risk with contemporary AI is that of misinterpreting what deep learning models do, and overestimating their abilities</p>
<p> A fundamental feature of the human mind is our “theory of mind”, our tendency to project intentions, beliefs and knowledge on the things around us</p>
<p>In particular, this is highlighted by “adversarial examples”, which are input samples to a deep learning network that are designed to trick the model into misclassifying them</p>
<p>By taking a picture of a panda and adding to it a “gibbon” gradient, we can get a neural network to classify this panda as a gibbon</p>
<p>In short, deep learning models do not have any understanding of their input, at least not in any human sense</p>
<p>never fall into the trap of believing that neural networks understand the task they perform they don’t, at least not in a way that would make sense to us</p>

<h2 id="Local-generalization-versus-extreme-generalization"><a href="#Local-generalization-versus-extreme-generalization" class="headerlink" title="Local generalization versus extreme generalization"></a>Local generalization versus extreme generalization</h2><p>This ability to handle hypotheticals, to expand our mental model space far beyond what we can experience directly, in a word, to perform <em>abstraction</em> and <em>reasoning</em>, is arguably the defining characteristic of human cognition— I call it “extreme generalization”: an ability to adapt to novel, never experienced before situations, using very little data or even no new data at all.</p>
<p>This stands in sharp contrast with what deep nets do, which I would call “local generalization”: the mapping from inputs to outputs performed by deep nets quickly stops making sense if new inputs differ even slightly from what they saw at training time. </p>
<p>人类有抽象建模能力，但是深度网络不行。如果想要训练在某个城市里自动驾驶的深度网络，可能需要出成千上百次错误，而换一个城市，这个网络就可能出现问题——但是人类不会</p>

<h2 id="Take-aways"><a href="#Take-aways" class="headerlink" title="Take-aways"></a>Take-aways</h2><p>To lift some of these limitations and start competing with human brains, we need to move away from straightforward input-to-output mappings, and on to <em>reasoning</em> and <em>abstraction</em>. </p>
<h1 id="future"><a href="#future" class="headerlink" title="future"></a>future</h1><p><a href="https://blog.keras.io/the-future-of-deep-learning.html" target="_blank" rel="noopener">https://blog.keras.io/the-future-of-deep-learning.html</a></p>
<h2 id="main-directions"><a href="#main-directions" class="headerlink" title="main directions"></a>main directions</h2><ul>
<li>Models closer to general-purpose computer programs, built on top of far richer primitives than our current differentiable layers—this is how we will get to <em>reasoning</em> and <em>abstraction</em>, the fundamental weakness of current models</li>
<li>New forms of learning that make the above possible—allowing models to move away from just differentiable transforms.</li>
<li>Models that require less involvement from human engineers—it shouldn’t be your job to tune knobs endlessly.</li>
<li>Greater, systematic reuse of previously learned features and architectures; meta-learning systems based on reusable and modular program subroutines.</li>
</ul>
<h2 id="Models-as-programs"><a href="#Models-as-programs" class="headerlink" title="Models as programs"></a>Models as programs</h2><p>a move away from models that perform purely <em>pattern recognition</em> and can only achieve <em>local generalization</em>, towards models capable of <em>abstraction</em> and <em>reasoning</em>, that can achieve <em>extreme generalization</em></p>
<p> In DeepMind’s AlphaGo, for example, most of the “intelligence” on display is designed and hard-coded by expert programmers (e.g. Monte-Carlo tree search); learning from data only happens in specialized submodules (value networks and policy networks). But in the future, such AI systems may well be fully learned, with no human involvement</p>
<p>例如RNN，不是简单的只用一个for，而是使用大量的编程原语，模型可以自由操作，以扩展其处理功能，如if分支、while语句、变量创建、长期内存磁盘存储、排序操作符、高级数据结构(如列表、图和哈希表)等等</p>
<p>  A big way is <em>program synthesis</em>， The difference is that instead of learning parameter values in a hard-coded program (a neural network), we generate <em>source code</em> via a discrete search process.</p>
<p>深度学习和program synthesis之间可能出现一个交叉子域，不会直接生成通用的编程语言编写的程序，而是生成神经网络，并通过for等编程原语来增强</p>
<h2 id="Beyond-backpropagation-and-differentiable-layers"><a href="#Beyond-backpropagation-and-differentiable-layers" class="headerlink" title="Beyond backpropagation and differentiable layers"></a>Beyond backpropagation and differentiable layers</h2><p>If machine learning models become more like programs, then they will mostly no longer be differentiable</p>
<p>We need to figure out to train non-differentiable systems efficiently. Current approaches include genetic algorithms, “evolution strategies”, certain reinforcement learning methods, and ADMM (alternating direction method of multipliers)</p>
<h2 id="Automated-machine-learning"><a href="#Automated-machine-learning" class="headerlink" title="Automated machine learning"></a>Automated machine learning</h2><p> Learning architectures automatically goes hand in hand with the use of richer sets of primitives and program-like machine learning models.</p>
<p>Unfortunately, the data munging part is tough to automate, since it often requires domain knowledge as well as a clear high-level understanding of what the engineer wants to achieve.</p>
<p>At the most basic level, such a system would simply tune the number of layers in a stack, their order, and the number of units or filters in each layer. </p>
<p>Another important AutoML direction is to learn model architecture jointly with model weights</p>
<h2 id="Lifelong-learning-and-modular-subroutine-reuse"><a href="#Lifelong-learning-and-modular-subroutine-reuse" class="headerlink" title="Lifelong learning and modular subroutine reuse"></a>Lifelong learning and modular subroutine reuse</h2><p>If models get more complex and are built on top of richer algorithmic primitives, then this increased complexity will require higher reuse between tasks</p>
<p>Much like you don’t learn English from scratch every time you open a new book—that would be impossible. </p>
<p>我们不仅会利用以前学习的功能（子模型权重），还会利用模型架构和训练过程。 随着模型变得更像程序，我们将开始重用程序子程序，例如人类编程语言中的函数和类</p>
<p>想想当今的软件开发过程：工程师解决了特定问题（例如，Python中的HTTP查询）后，他们会将其打包为一个抽象且可重用的库。 将来面临类似问题的工程师可以简单地搜索现有的库，下载一个库并在自己的项目中使用它。 以类似的方式，将来，元学习系统将能够通过在高级可重用块的全局库中进行筛选来组装新程序。 当系统发现自己正在为几种不同的任务开发类似的程序子例程时，就会提出一个“抽象的”、可重用的子程序版本，并将其存储在全局库中。 这样的过程将实现抽象的能力，这是实现“极端泛化”的必要组件：可以说跨不同任务和领域有用的子例程可以“抽象”问题解决的某些方面。 “抽象”的定义类似于软件工程中的抽象概念。 这些子例程可以是geometric （具有预训练表示形式的深度学习模块），也可以是algorithmic （更接近于当代软件工程师操作的库）</p>
<h2 id="Deep-learning-in-artificial-intelligence-solid-development-amp-tricks"><a href="#Deep-learning-in-artificial-intelligence-solid-development-amp-tricks" class="headerlink" title="Deep learning in artificial intelligence: solid development &amp; tricks"></a>Deep learning in artificial intelligence: solid development &amp; tricks</h2><p>How does a deep network work?</p>
<p>• Intuitive design or theoretical foundation?</p>
<p>• Change network structure but why is a structure better than another?</p>
<p>• Adjust hyper-parameters but why are these hyper-parameters better than those?</p>
<p>• Making a prediction but what is the rationale of the prediction</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/29/namingJava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/29/namingJava/" itemprop="url">Android项目命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-29T18:05:42+08:00">
                2021-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  183
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面向贡献者的 AOSP 代码样式指南：<a href="https://source.android.com/source/code-style#follow-field-naming-conventions" target="_blank" rel="noopener">https://source.android.com/source/code-style#follow-field-naming-conventions</a><br>Android：你不能忽略的代码命名规范：<a href="https://www.jianshu.com/p/b7a644ea0d25" target="_blank" rel="noopener">https://www.jianshu.com/p/b7a644ea0d25</a></p>

<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><img src="/2021/01/29/namingJava/3.png" class>
<h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>小骆驼拼写法（除首字母外各个单词首字母全部大写）</p>
<p>非静态非public成员以m开头<br>静态全部大写，下划线分割</p>
<p>临时变量全部小写</p>
<h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><img src="/2021/01/29/namingJava/4.png" class>
<p>参数小骆驼法</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><img src="/2021/01/29/namingJava/5.webp" class>
<p>按照小写+下划线隔开的规则</p>
<p>可以参考下面的命名方式（有些繁琐，且缩写不便记忆）</p>
<img src="/2021/01/29/namingJava/6.webp" class><img src="/2021/01/29/namingJava/7.webp" class><img src="/2021/01/29/namingJava/8.webp" class><img src="/2021/01/29/namingJava/9.webp" class><img src="/2021/01/29/namingJava/10.webp" class><img src="/2021/01/29/namingJava/11.webp" class>
<h1 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h1><p>大骆驼</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>每个类/函数加上注释<br>左大括号不单独占一行，与其前面的代码位于同一行</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/28/MVVMSample/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/28/MVVMSample/" itemprop="url">MVVMSample</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-28T13:50:27+08:00">
                2021-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/KunMinX/Jetpack-MVVM-Best-Practice" target="_blank" rel="noopener">https://github.com/KunMinX/Jetpack-MVVM-Best-Practice</a></p>
<h2 id="strict-databinding-3-6-2-beta1-sources"><a href="#strict-databinding-3-6-2-beta1-sources" class="headerlink" title="strict-databinding-3.6.2-beta1-sources"></a>strict-databinding-3.6.2-beta1-sources</h2><h3 id="DataBindingActivity-java"><a href="#DataBindingActivity-java" class="headerlink" title="DataBindingActivity.java"></a>DataBindingActivity.java</h3><h4 id="数据绑定库"><a href="#数据绑定库" class="headerlink" title="数据绑定库"></a>数据绑定库</h4><p>文档太晦涩<a href="https://juejin.cn/post/6844903784284422152" target="_blank" rel="noopener">https://juejin.cn/post/6844903784284422152</a></p>
<p><a href="https://developer.android.com/topic/libraries/data-binding/start" target="_blank" rel="noopener">https://developer.android.com/topic/libraries/data-binding/start</a></p>
<p>数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。借助布局文件中的绑定组件，您可以移除 Activity 中的许多界面框架调用，使其维护起来更简单、方便。可以采用表达式语言进行更复杂的绑定。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.userName&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>要将应用配置为使用数据绑定，请在应用模块的 <code>build.gradle</code> 文件中添加 <code>dataBinding</code> 元素</p>
<p>数据绑定布局文件略有不同，以根标记 <code>layout</code> 开头，后跟 <code>data</code> 元素和 <code>view</code> 根元素</p>
<p>系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写形式并在末尾添加 Binding 后缀；建议的绑定创建方法是在扩充布局时创建</p>
<p>如果您要在 <code>Fragment</code>、<code>ListView</code> 或 <code>RecyclerView</code> 适配器中使用数据绑定项，您可能更愿意使用绑定类或<code>DataBindingUtil</code>类的 <code>inflate()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>inflate()</code>有多个绑定版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    MyLayoutBinding binding = MyLayoutBinding.inflate(getLayoutInflater());</span><br><span class="line"></span><br><span class="line">    setContentView(binding.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);</span><br></pre></td></tr></table></figure>
<p>通过数据绑定，您可以编写从视图分派的表达式处理事件。可以采用两种机制：</p>
<p>方法引用:事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定 <a href="https://developer.android.com/reference/android/view/View#attr_android:onClick" target="_blank" rel="noopener"><code>android:onClick</code></a> 的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickFriend</span><span class="params">(View view)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"handlers"</span> <span class="attr">type</span>=<span class="string">"com.example.MyHandlers"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:onClick</span>=<span class="string">"@&#123;handlers::onClickFriend&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>监听器绑定:监听器绑定是在事件发生时运行的绑定表达式。它们类似于方法引用，但允许您运行任意数据绑定表达式。在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveClick</span><span class="params">(Task task)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"task"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Task"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"presenter"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Presenter"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span> <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">"@&#123;() -&gt; presenter.onSaveClick(task)&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>您可以忽略方法的所有参数，也可以命名所有参数。如果您想命名参数，则可以在表达式中使用这些参数</p>
<p>可以在布局文件中导入类，定义变量等</p>
<p>可观察性是指一个对象将其数据变化告知其他对象的能力。通过数据绑定库，您可以让对象、字段或集合变为可观察。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; firstName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; lastName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableInt age = <span class="keyword">new</span> ObservableInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要访问字段，需要使用set（）与get（）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.firstName.set(<span class="string">"Google"</span>);</span><br><span class="line"><span class="keyword">int</span> age = user.age.get();</span><br></pre></td></tr></table></figure>
<p>所有生成的绑定类都是从 <a href="https://developer.android.com/reference/androidx/databinding/ViewDataBinding" target="_blank" rel="noopener"><code>ViewDataBinding</code></a> 类继承而来的</p>
<p>标准可观察字段有许多，例如ObservableArrayMap，ObservableArrayList等</p>
<p>实现 <a href="https://developer.android.com/reference/android/databinding/Observable" target="_blank" rel="noopener"><code>Observable</code></a> 接口的类允许注册监听器，以便它们接收有关可观察对象的属性更改的通知。为便于开发，数据绑定库提供了用于实现监听器注册机制的 <a href="https://developer.android.com/reference/android/databinding/BaseObservable" target="_blank" rel="noopener"><code>BaseObservable</code></a> 类。实现 <code>BaseObservable</code> 的数据类负责在属性更改时发出通知。具体操作过程是向 getter 分配 <a href="https://developer.android.com/reference/android/databinding/Bindable" target="_blank" rel="noopener"><code>Bindable</code></a> 注释，然后在 setter 中调用 <a href="https://developer.android.com/reference/android/databinding/BaseObservable#notifypropertychanged" target="_blank" rel="noopener"><code>notifyPropertyChanged()</code></a> 方法。数据绑定在模块包中生成一个名为 <code>BR</code> 的类，该类包含用于数据绑定的资源的 ID。在编译期间，<a href="https://developer.android.com/reference/android/databinding/Bindable" target="_blank" rel="noopener"><code>Bindable</code></a> 注释会在 <code>BR</code> 类文件中生成一个条目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        notifyPropertyChanged(BR.firstName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        notifyPropertyChanged(BR.lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绑定适配器负责发出相应的框架调用来设置值。只要绑定值发生更改，生成的绑定类就必须使用绑定表达式在视图上调用 setter 方法。您可以允许数据绑定库自动确定方法、显式声明方法或提供选择方法的自定义逻辑。</p>
<p>设置特征值</p>
<ul>
<li><p>自动选择</p>
</li>
<li><p>指定自定义方法：使用使用 <a href="https://developer.android.com/reference/androidx/databinding/BindingMethods" target="_blank" rel="noopener"><code>BindingMethods</code></a> 注释与 setter 相关联。注释与类一起使用，可以包含多个 <a href="https://developer.android.com/reference/androidx/databinding/BindingMethod" target="_blank" rel="noopener"><code>BindingMethod</code></a> 注释，每个注释对应一个重命名的方法</p>
</li>
<li><p>```java</p>
<pre><code>@BindingMethods({
       @BindingMethod(type = &quot;android.widget.ImageView&quot;,
                      attribute = &quot;android:tint&quot;,
                      method = &quot;setImageTintList&quot;),
})
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 提供自定义逻辑：例如，&#96;android:paddingLeft&#96; 特性没有关联的 setter，而是提供了 &#96;setPadding(left, top, right, bottom)&#96; 方法。使用 [&#96;BindingAdapter&#96;](https:&#x2F;&#x2F;developer.android.com&#x2F;reference&#x2F;androidx&#x2F;databinding&#x2F;BindingAdapter) 注释的静态绑定适配器方法支持自定义特性 setter 的调用方式。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">    @BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="line">    public static void setPaddingLeft(View view, int padding) &#123;</span><br><span class="line">      view.setPadding(padding,</span><br><span class="line">                      view.getPaddingTop(),</span><br><span class="line">                      view.getPaddingRight(),</span><br><span class="line">                      view.getPaddingBottom());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参数类型非常重要。第一个参数用于确定与特性关联的视图类型，第二个参数用于确定在给定特性的绑定表达式中接受的类型</p>
<h4 id="将架构组件整合到应用"><a href="#将架构组件整合到应用" class="headerlink" title="将架构组件整合到应用"></a>将架构组件整合到应用</h4><p>将LiveData作为数据绑定来源：您需要指定生命周期所有者来定义 <code>LiveData</code> 对象的范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line">        UserBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Specify the current activity as the lifecycle owner.</span></span><br><span class="line">        binding.setLifecycleOwner(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ViewModel管理相关数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Obtain the ViewModel component.</span></span><br><span class="line">        UserModel userModel = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>).get(UserModel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line">        UserBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assign the component to a property in the binding class.</span></span><br><span class="line">        binding.viewmodel = userModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:checked</span>=<span class="string">"@&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;() -&gt; viewmodel.rememberMeChanged()&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用observable ViewModel从 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 类继承而来并实现 <a href="https://developer.android.com/reference/androidx/databinding/Observable" target="_blank" rel="noopener"><code>Observable</code></a> 接口的类。可以使用 <a href="https://developer.android.com/reference/androidx/databinding/Observable#addOnPropertyChangedCallback(android.databinding.Observable.OnPropertyChangedCallback" target="_blank" rel="noopener"><code>addOnPropertyChangedCallback()</code></a>) 和 <a href="https://developer.android.com/reference/androidx/databinding/Observable#removeOnPropertyChangedCallback(android.databinding.Observable.OnPropertyChangedCallback" target="_blank" rel="noopener"><code>removeOnPropertyChangedCallback()</code></a>) 方法提供观察器订阅或取消订阅通知时的自定义逻辑。还可以在 <a href="https://developer.android.com/reference/androidx/databinding/BaseObservable#notifyPropertyChanged(int" target="_blank" rel="noopener"><code>notifyPropertyChanged()</code></a>) 方法中提供属性更改时运行的自定义逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A ViewModel that is also an Observable,</span></span><br><span class="line"><span class="comment"> * to be used with the Data Binding Library.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObservableViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> <span class="keyword">implements</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PropertyChangeRegistry callbacks = <span class="keyword">new</span> PropertyChangeRegistry();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addOnPropertyChangedCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Observable.OnPropertyChangedCallback callback)</span> </span>&#123;</span><br><span class="line">        callbacks.add(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeOnPropertyChangedCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Observable.OnPropertyChangedCallback callback)</span> </span>&#123;</span><br><span class="line">        callbacks.remove(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies observers that all properties of this instance have changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies observers that a specific property has changed. The getter for the</span></span><br><span class="line"><span class="comment">     * property that changes should be marked with the <span class="doctag">@Bindable</span> annotation to</span></span><br><span class="line"><span class="comment">     * generate a field in the BR class to be used as the fieldId parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldId The generated BR id for the Bindable field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyPropertyChanged</span><span class="params">(<span class="keyword">int</span> fieldId)</span> </span>&#123;</span><br><span class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, fieldId, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h4><p>使用getDataBindingConfig得到config并进行绑定，绑定至mBinding</p>
<h4 id="getBinding"><a href="#getBinding" class="headerlink" title="getBinding"></a>getBinding</h4><p>返回ViewDataBinding</p>
<h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><h4 id="lt-receiver-gt"><a href="#lt-receiver-gt" class="headerlink" title="&lt; /receiver&gt;"></a>&lt; /receiver&gt;</h4><p>所有静态注册的广播接收器都是在这里进行注册的。首先通过 android:name 来指定具体注册哪一个广播接收器，然后在标签里加入想要接收的广播就行了</p>
<p>例如Android系统启动完成后会发出一条值为 android.intent.action.BOOT_COMPLETED的广 播</p>
<h2 id="architecture"><a href="#architecture" class="headerlink" title="architecture"></a>architecture</h2><h3 id="AndroidManifest-xml-1"><a href="#AndroidManifest-xml-1" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><h4 id="lt-meta-data-gt"><a href="#lt-meta-data-gt" class="headerlink" title="&lt; meta-data &gt;"></a>&lt; meta-data &gt;</h4><p>标签可以为其父组件提供额外的，能够被外地访问的数据，它很方便的增加了相应组件的个性化数据，原则上想添加多少就多少，但是不建议添加多行</p>
<p>它采用键-值（name-value）的形式来存储数据，自定义名称</p>
<h4 id="lt-provider-gt"><a href="#lt-provider-gt" class="headerlink" title="&lt; provider&gt;"></a>&lt; provider&gt;</h4><p>注册内容提供器</p>
<h3 id="CommonViewPagerAdapter-java"><a href="#CommonViewPagerAdapter-java" class="headerlink" title="CommonViewPagerAdapter.java"></a>CommonViewPagerAdapter.java</h3><p><a href="https://www.kaelli.com/30.html" target="_blank" rel="noopener">https://www.kaelli.com/30.html</a></p>
<h4 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h4><p>ViewPager是一个布局容器，实际上是一个特别的ViewGroup。它允许用户通过左右滑动翻页的操作来实现数据展示的变化（实际上可以修改后实现竖直方向的上下翻页）。ViewPager需要设置由开发者实现的适配器PagerAdapter，以此来决定在每个位置上该展示什么样的数据</p>
<h4 id="PagerAdapter"><a href="#PagerAdapter" class="headerlink" title="PagerAdapter"></a>PagerAdapter</h4><p>抽象类，至少实现4个方法</p>
<ul>
<li>getCount：一共有多少个页面</li>
<li>isViewFromObject：page 和object是否关联</li>
<li>instantiateItem：创建给定位置的页面，适配器会把创建的View添加到给定的容器container中</li>
<li>destroyItem：移除给定位置的页面，适配器会把View从容器里删除</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/14/CPF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/14/CPF/" itemprop="url">CPF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-14T13:55:34+08:00">
                2020-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  959
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ContactPotentialField (CPF):</p>
<p>建模物体与手之间的接触，建立弹性势能的场，这样就可以把问题转化为最小化势能</p>
<p>Modeling theInteraction sce-nario ofHand andObject,MIHO</p>
<p>学习框架</p>
<p>k-mano</p>
<p>沿twist-splay-bend轴进行运动学限制，同时指骨区域通过下采样加上了锚点。锚点用来计算弹性，简化计算</p>
<img src="/2020/12/14/CPF/1.PNG" class>
<p>CPF</p>
<p>通过弹簧质点系统处理接触</p>
<p>接触就是一个弹簧系统：两个单位质点分别位于物体与手，分别为$V_j^o,V_i^h$</p>
<p>吸引弹簧：将物体上的每个点与最近的手上的点连接弹簧</p>
<p>排斥弹簧：</p>
<img src="/2020/12/14/CPF/2.PNG" class>
<p>求得最自然的手势，即为求势能最小之和：</p>
<p>$E_{elast}=\sum_i^{N_H}\sum_j^{N_O}(E_{ij}^{atr}+E_{ij}^{rpl})$</p>
<p>与之前一样，计算时实际上用的是手上的锚点</p>
<img src="/2020/12/14/CPF/4.PNG" class>
<p>$k_{ij}^{atr}$为可学习的参数，为了每个吸引力基本平衡，与$\Delta l_ij$成反比。为了学习这个参数，生成了许多伪ground truth，<script type="math/tex">K_{ij}^{GT}</script>,然后以此训练模型</p>
<p>经验上将$k_{ij}^{rpl}$设为1e-3</p>
<p>MIHO</p>
<img src="/2020/12/14/CPF/3.PNG" class>
<p>HoNet粗略回归出物体和手势</p>
<p> Pixel-wise  Contact  Recovery.PiCR</p>
<img src="/2020/12/14/CPF/5.PNG" class>
<p>pi为透视投影；b为backbone，Hourglass Networks ；z为物体z坐标（因为投影损失了），f为PIFu，hvc,hcr，hae都是PointNet</p>
<p>$VC \in R^{N_o}$为物体上每个点与手接触的概率</p>
<img src="/2020/12/14/CPF/6.PNG" class>
<p>$CR \in R^{N_O \times 17}$,落在17个区域的概率</p>
<img src="/2020/12/14/CPF/7.PNG" class>
<p>$AE \in R^{N_o}$,$k_{ij}$的预测值，属于0~1，可以看作物体与手的接近程度</p>
<img src="/2020/12/14/CPF/8.PNG" class>
<img src="/2020/12/14/CPF/9.PNG" class>
<p>Grasping Energy Optimizer, GeO</p>
<p>通过预测的CPF来改进HoNet预测值</p>
<p>预测物体等于预测变换矩阵</p>
<p>对于mano</p>
<p>首先，防止手弯折，twist</p>
<p>其次，对于非关节点，惩罚splay</p>
<p>然后，惩罚bend如果超过90°</p>
<p>然后惩罚预测的偏移</p>
<img src="/2020/12/14/CPF/10.PNG" class>
<p>Datasets</p>
<p>First-person hand action benchmark, FHB</p>
<p>  In our experiments, we use a subset of FHBthat contains 4 objects with a scanned model and pose anno-tation. We only use theactionsplit following the protocol of[19, 43], and filter out the samples with a minimum hand-object distance greater than 5mm,  which yields us 7223samples for training and 7373 for testing.</p>
<p>HO3D</p>
<p>Metrics</p>
<p>Mean 3D errors，顶点误差</p>
<p>Penetration depth，穿过的最大距离</p>
<p>Solid intersection volume，将物体体素化，与手重叠的数量和</p>
<p>Disjointedness  errors，指尖区域顶点距离最近的物体表面的平均值</p>
<p>Abnormality scores，手twist和spay的平均距离</p>
<p>Implementation Details</p>
<p>K-mano</p>
<p>需要将轴角分解为twist， splay， bend。首先将mano自带的作为splay，子节点指向该节点的方向作为twist，叉乘得到bend；然后将bend与twist叉乘得到最后的splay</p>
<p>锚点需要在手的表面，同时需要对mano参数可导。每一个锚点可以用周围的三个顶点线性组合，从而梯度传到mano参数上</p>
<img src="/2020/12/14/CPF/11.PNG" class>
<p>生成锚点需要控制点，有些位置控制点就是锚点；指尖需要提升锚点的密度，首先过控制点做直线找到交点，然后做锥形，控制点是顶点，交点为基准点中心，根据区域内各点到控制点的最大距离估计基准点半径;选择三种均匀分布在锥面上的射线作为新的射线投射方向，得到锚点</p>
<p>Elastic Energy Analysis</p>
<img src="/2020/12/14/CPF/12.PNG" class>
<p>直接使用一个神经网络预测<script type="math/tex">k^{GT}_{ij}</script>容易过拟合，因此使用层连网络</p>
<p>HO3D Dataset</p>
<p>因为要6D，很多物体不适合，比如水罐；而且对于很多测试集中的抓取姿势并不稳定，比如bleach cleanser bottle</p>
<p> Data Augmentation</p>
<p>为了生成更多姿态，随机扰动带标注的手与物体的姿态，在物体系下；然后渲染到相机系下；</p>
<p>生成更多稳定的抓取姿态：手动将手围绕包围盒移动，使用GeO改善姿态。但是这里无法使用CPF中的attractive  springs，因此使用其他方法来替代 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/03/cpp-primer2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/03/cpp-primer2/" itemprop="url">cpp primer笔记2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-03T10:44:58+08:00">
                2020-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  651
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h3><h4 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h4><img src="/2020/12/03/cpp-primer2/1.PNG" class>
<p>char虽然不是io类，但是也可以进行形似的操作</p>
<img src="/2020/12/03/cpp-primer2/9.PNG" class>
<p>IO对象无法拷贝，因此不能将形参或者返回类型设置为流类型，通常应该使用引用</p>
<img src="/2020/12/03/cpp-primer2/2.PNG" class>
<p>badit表示系统级错误，一般置位后流无法再使用；failit一般指可恢复错误，通常可以修复；到达文件尾部，eof与failbit都会置位。</p>
<p>一般使用good与！fail判断流的总体状态</p>
<p>rdstate初始化值为0，badbit等实际是掩码，即该bit实际对应的是哪一位，与rdstate进行操作后可以得到最终结果</p>
<p>为了节约时间，引入了缓冲区机制</p>
<img src="/2020/12/03/cpp-primer2/3.PNG" class>
<img src="/2020/12/03/cpp-primer2/4.PNG" class>
<p>flush刷新缓冲区，ends插入空字符后刷新缓冲区</p>
<p>使用unibuf操纵符后每一次写操作自动进行一次flush操作</p>
<p>tie函数具有两个版本：不带参数的返回指向输出流的指针；带参数的接受一个指向ostream的指针，将自己关联到这个指针上</p>
<p>每个流最多同时关联到一个流，但是多个流可以同时关联到同一个ostream上</p>
<h4 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h4><img src="/2020/12/03/cpp-primer2/5.PNG" class>
<p>可以使用open与close关联文件，如果open失败可以检查failbit</p>
<p>当fstream对象被销毁时，比如离开定义域，会自动调用close</p>
<img src="/2020/12/03/cpp-primer2/6.PNG" class>
<img src="/2020/12/03/cpp-primer2/7.PNG" class>
<p>可以看到模式实际也是类似掩码的类型</p>
<p>每一次调用open时都可以改变文件模式</p>
<img src="/2020/12/03/cpp-primer2/8.PNG" class>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><img src="/2020/12/03/cpp-primer2/10.PNG" class>
<img src="/2020/12/03/cpp-primer2/11.PNG" class>
<img src="/2020/12/03/cpp-primer2/12.PNG" class>
<img src="/2020/12/03/cpp-primer2/13.PNG" class>
<img src="/2020/12/03/cpp-primer2/14.PNG" class>
<img src="/2020/12/03/cpp-primer2/15.PNG" class>
<img src="/2020/12/03/cpp-primer2/16.PNG" class>
<p>因为插入时是在iter的前面插入，恰好能够在任何一个位置包括最末/最初插入元素</p>
<p>除array外，swap不对任何元素进行拷贝删除或插入，可以再常数时间内完成。array的swap操作会真正的交换他们的元素</p>
<p>新标准库中既有成员函数的swap，又有非成员版本的swap</p>
<p>容器也可以进行比较，比较与char数组的比较模式相同</p>
<img src="/2020/12/03/cpp-primer2/17.PNG" class>
<p>push_back本质是在容器尾部创建添加了新元素，是拷贝而不是元素本身</p>
<img src="/2020/12/03/cpp-primer2/18.PNG" class>
<img src="/2020/12/03/cpp-primer2/19.PNG" class>
<p>容器的返回值只是拷贝，如果想要引用需要加上引用类型</p>
<p>下标运算符并不检查是否越界，at函数可以检测，越界后会报错</p>
<img src="/2020/12/03/cpp-primer2/20.PNG" class>
<img src="/2020/12/03/cpp-primer2/21.PNG" class>
<img src="/2020/12/03/cpp-primer2/22.PNG" class>
<img src="/2020/12/03/cpp-primer2/23.PNG" class>
<p>不要保存end返回的迭代器，因为每一次插入和弹出会使得之前的end失效</p>
<img src="/2020/12/03/cpp-primer2/24.PNG" class>
<img src="/2020/12/03/cpp-primer2/25.PNG" class>
<img src="/2020/12/03/cpp-primer2/26.PNG" class>
<p>string类提供了很多搜索函数，如果搜索失败，就会返回一个string::npos的static成员，这个成员的类型是const string::size_type成员，初始化为-1</p>
<img src="/2020/12/03/cpp-primer2/27.PNG" class>
<img src="/2020/12/03/cpp-primer2/28.PNG" class>
<img src="/2020/12/03/cpp-primer2/29.PNG" class>
<img src="/2020/12/03/cpp-primer2/30.PNG" class>
<p>适配器例如stack，stack<string,vector< string> &gt;即vector作为基本容器，保存string，同时按照栈行事的一种结构</string,vector<></p>
<p>第二个参数——基本结构可以省去，stack与queue都是默认deque</p>
<img src="/2020/12/03/cpp-primer2/31.PNG" class>
<h3 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h3><p>标准库没有给每一个容器加入大量功能，而是提供了一组可以共用的算法</p>
<p>迭代器令算法不依赖于容器，但是算法依赖于元素类型的操作（例如元素之间如何比较）</p>
<img src="/2020/12/03/cpp-primer2/32.PNG" class>
<p>泛型算法有上百个</p>
<p>只读算法</p>
<p>find，count，accumulate</p>
<img src="/2020/12/03/cpp-primer2/33.PNG" class>
<p>equal，接受三个迭代器：第一个容器的起止，第二个序列的首元素。它默认第二个序列至少与前者一样长，它也只检查那么长。接受三个迭代器的算法都是这样，注意不要越界了</p>
<p>对于操作两个容器的函数，可能两个容器元素内的类型根本不一样，但是只要两者能够比较即可</p>
<p>fill，接受一对迭代器表示范围，第三个参数表示要填上的元素值</p>
<p>fill_n，第一个为迭代器，第二个参数表示写入的元素数，第三个表示写入的值。注意算法不检查写操作，一定要写入的位置之前就有元素才行</p>
<p>插入迭代器：通过这种迭代器赋值，实际是插入了一个新的元素</p>
<p>back_inserter，接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器，通过这个迭代器赋值，就会加入这个定值的元素</p>
<img src="/2020/12/03/cpp-primer2/34.PNG" class>
<p>copy，经典三个迭代器，也是需要接收方已经有这么多的空间。返回值恰好是拷贝的尾元素后的位置</p>
<img src="/2020/12/03/cpp-primer2/35.PNG" class>
<p>这个拷贝的目的也需要对应长度的空间，或者用插入迭代器</p>
<img src="/2020/12/03/cpp-primer2/36.PNG" class>
<p>非常怪的方法。unique不能清除元素——标准库算法都是对迭代器操作，无法直接添加与删除元素。unique的作用就是把重复的元素都换到序列最后，返回第一个重复元素的位置</p>
<p>有些算法需要比较元素，对于这种算法可以进行定制，使用自定义的操作符。这种算法需要的额外参数叫谓词，分为一元与二元谓词</p>
<p>对于更灵活的使用情况，c++11引入了lambda表达式</p>
<img src="/2020/12/03/cpp-primer2/37.PNG" class>
<p>如果忽略返回类型，只有一个return，lambda会自己推测；如果函数体内，包括除return语句之外的内容，且没有指明返回类型，则返回void</p>
<p>lambda可以使用环境的局部变量，但是必须在列表内指明，cin等全局变量不用</p>
<img src="/2020/12/03/cpp-primer2/38.PNG" class>
<p>如果想要在lambda里改变捕获的变量，需要在参数列表首加上关键字mutable</p>
<p>c++11引入了bind函数，这个函数本质也是一个适配器</p>
<img src="/2020/12/03/cpp-primer2/39.PNG" class>
<p>_n名字存放在std::place_holder命名空间</p>
<img src="/2020/12/03/cpp-primer2/40.PNG" class>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/NaNillll" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
  
 
  
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">42.9k</span>
  
</div>











        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
