<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta name="google-site-verification" content="kWcVT9oyylmyb6DohoXWge7VpBUZQVIptcOSS5Gr9wc" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="The Grimoire of NaNillll">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="The Grimoire of NaNillll">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>The Grimoire of NaNillll</title>
  








<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">The Grimoire of NaNillll</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/11/ComputerNetwork7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/11/ComputerNetwork7/" itemprop="url">应用层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-11T11:17:23+08:00">
                2021-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。</p>
<p>应用层的许多协议都是基于客户服务器方式。客户是服务请求方，服务器是服务提供方。  </p>
<p>熟知端口号：应用层协议在服务器端的默认端口号，客户端进程的端口号是客户端进程任意临时指定的</p>
<h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><p>互联网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统 DNS。</p>
<p>名字到 IP 地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">… . 三级域名 . 二级域名 . 顶级域名</span><br></pre></td></tr></table></figure>
<img src="/2021/03/11/ComputerNetwork7/1.png" class>
<img src="/2021/03/11/ComputerNetwork7/2.png" class>
<p>根域名服务器：最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。</p>
<p>顶级域名服务器（即 TLD 服务器）：负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。 </p>
<p>权限域名服务器 ：负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。 </p>
<p>本地域名服务器 ，本地域名服务器对域名系统非常重要。当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。 </p>
<h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p>使用迭代查询</p>
<img src="/2021/03/11/ComputerNetwork7/3.png" class>
<h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><p>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。<br>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。<br>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。</p>
<img src="/2021/03/11/ComputerNetwork7/4.png" class>
<p>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 (21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。<br>接着，服务器进程用自己传送数据的熟知端口 (20) 与客户进程所提供的端口号码建立数据传送连接。</p>
<h2 id="简单文件传送协议-TFTP"><a href="#简单文件传送协议-TFTP" class="headerlink" title="简单文件传送协议 TFTP"></a>简单文件传送协议 TFTP</h2><p>一个很小且易于实现的文件传送协议。TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 </p>
<p>(1) 每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。<br>(2) 数据 PDU 也称为文件块 (block)，每个块按序编号，从 1 开始。<br>(3) 支持 ASCII 码或二进制传送。<br>(4) 可对文件进行读或写。<br>(5) 使用很简单的首部。 </p>
<p>传输过程类似停止等待协议：传送一个文件块后就等待；超时没有收到确认PDU重传；超时收不到下一个文件块也重发确认PDU</p>
<h2 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h2><p>TELNET 是一个简单的远程终端协议，也是互联网的正式标准。用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。</p>
<p>TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机则运行 TELNET 服务器进程。和 FTP 的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。 </p>
<h2 id="万维网-WWW"><a href="#万维网-WWW" class="headerlink" title="万维网 WWW"></a>万维网 WWW</h2><p>万维网是一个大规模的、联机式的信息储藏所。<br>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</p>
<p>万维网是分布式超媒体 (hypermedia) 系统，它是超文本 (hypertext) 系统的扩充。<br>一个超文本由多个信息源链接成。利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在互联网上的超文本系统中。超文本是万维网的基础。<br>超媒体与超文本的区别是文档内容不同。超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。</p>
<p>万维网以客户-服务器方式工作。浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。<br>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。在一个客户程序主窗口上显示出的万维网文档称为页面 (page)。</p>
<p>使用统一资源定位符 URL (Uniform Resource Locator) 来标志万维网上的各种文档。<br>使每一个文档在整个互联网的范围内具有唯一的标识符 URL。</p>
<p>URL 的一般形式：  &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; ，端口与路径有时可省略</p>
<p>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 </p>
<p>超文本标记语言 HTML (HyperText Markup Language) 使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。 </p>
<h3 id="超文本传送协议-HTTP"><a href="#超文本传送协议-HTTP" class="headerlink" title="超文本传送协议 HTTP"></a>超文本传送协议 HTTP</h3><img src="/2021/03/11/ComputerNetwork7/5.png" class>
<img src="/2021/03/11/ComputerNetwork7/6.png" class>
<p>服务器web连接默认端口号80</p>
<p>HTTP是无状态的，服务器不记得给某个用户服务过多少次了</p>
<p>HTTP既可以用非持久连接（每个网页元素的传输都必须单独建立一个TCP连接）；或者持久连接（HTTP/1.1支持，同一个客户与服务器可以继续在这条连接上传输后续的报文与请求）</p>
<p>持久连接又分流水线（HTTP/1.1默认，可以连续发送多个请求/相应。所有的引用对象共计1个RTT延迟）与非流水线（客户收到前一个相应后才能发出下一个请求）两种</p>
<h4 id="HTTP报文，HTTP请求，HTTPS"><a href="#HTTP报文，HTTP请求，HTTPS" class="headerlink" title="HTTP报文，HTTP请求，HTTPS"></a>HTTP报文，HTTP请求，HTTPS</h4><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>代理服务器 (proxy server) 又称为万维网高速缓存 (Web cache)，它代表浏览器发出 HTTP 请求。<br>万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。<br>当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去互联网访问该资源。 </p>
<p>浏览器访问互联网的服务器时，先于代理服务器建立TCP缓存并HTTP访问。如果有缓存就直接返回；否则代理服务器发出HTTP请求，得到资源后缓存，再通过已经建立的TCP连接返回给服务器</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>万维网站点使用 Cookie 来跟踪用户。<br>Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。<br>使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。  </p>
<h3 id="动态万维网文档"><a href="#动态万维网文档" class="headerlink" title="动态万维网文档"></a>动态万维网文档</h3><p>静态文档是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。<br>动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。<br>动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。  </p>
<img src="/2021/03/11/ComputerNetwork7/7.png" class>
<p>CGI (Common Gateway Interface) 是一种标准，它定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出结果应如何使用。</p>
<h3 id="活动万维网文档"><a href="#活动万维网文档" class="headerlink" title="活动万维网文档"></a>活动万维网文档</h3><p>活动文档 (active document) 技术把所有的工作都转移给浏览器端。每当浏览器请求一个活动文档时，服务器就返回一段程序副本在浏览器端运行。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。 </p>
<img src="/2021/03/11/ComputerNetwork7/8.png" class>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>发送邮件的协议：SMTP<br>读取邮件的协议：POP3 和 IMAP</p>
<img src="/2021/03/11/ComputerNetwork7/9.png" class>
<p>收件人邮箱名@邮箱所在主机的域名      ，邮箱名再域名的范围内一定是唯一的</p>
<h3 id="简单邮件传送协议-SMTP"><a href="#简单邮件传送协议-SMTP" class="headerlink" title="简单邮件传送协议 SMTP"></a>简单邮件传送协议 SMTP</h3><p>SMTP 使用客户服务器方式，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。  </p>
<ol>
<li>连接建立：连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。   SMTP熟知端口号25</li>
<li>邮件传送</li>
<li>连接释放：邮件发送完毕后，SMTP 应释放 TCP 连接。 </li>
</ol>
<p>发件人的邮件发送到</p>
<h3 id="邮件读取协议POP3"><a href="#邮件读取协议POP3" class="headerlink" title="邮件读取协议POP3"></a>邮件读取协议POP3</h3><p>POP 也使用客户-服务器的工作方式。<br>在接收邮件的用户 PC 机中必须运行 POP 客户程序，而在用户所连接的 ISP 的邮件服务器中则运行 POP 服务器程序。   </p>
<p>在传输层使用TCP，端口号110，有下载并保存与下载并删除两种模式</p>
<h3 id="邮件读取协议和-IMAP"><a href="#邮件读取协议和-IMAP" class="headerlink" title="邮件读取协议和 IMAP"></a>邮件读取协议和 IMAP</h3><p>也是按客户服务器方式工作。<br>用户在自己的 PC 机上就可以操纵 ISP 的邮件服务器的邮箱，就像在本地操纵一样。<br>因此 IMAP 是一个联机协议。当用户 PC 机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。 同时也允许收件人只读邮件中的某一个部分。</p>
<p>IMAP 的缺点是如果用户没有将邮件复制到自己的 PC 上，则邮件一直是存放在 IMAP 服务器上。</p>
<h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p>很常见</p>
<h2 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h2><p>在 P2P 工作方式下，所有的音频/视频文件都是在普通的互联网用户之间传输。这是相当于有很多分散在各地的媒体服务器向其他用户提供所要下载的音频/视频文件。 </p>
<h3 id="集中目录服务器-P2P-Napster"><a href="#集中目录服务器-P2P-Napster" class="headerlink" title="集中目录服务器 P2P Napster"></a>集中目录服务器 P2P Napster</h3><p>Napster 能够搜索音乐文件，能够提供检索功能。所有的音乐文件地址集中存放在一个 Napster 目录服务器中。使用者可很方便地下载需要的 MP3 文件。<br>用户要及时向 Napster 的目录服务器报告自己存有的音乐文件。当用户想下载某个 MP3 文件时，就向目录服务器发出询问。目录服务器检索出结果后向用户返回存放此文件的 PC 机的 IP 地址。Napster 的文件传输是分散的，但文件的定位则是集中的。<br>这种集中式目录服务器的缺点就是可靠性差。</p>
<h3 id="全分布式结构的-P2P-Gnutella"><a href="#全分布式结构的-P2P-Gnutella" class="headerlink" title="全分布式结构的 P2P Gnutella"></a>全分布式结构的 P2P Gnutella</h3><p>Gnutella 与 Napster 最大的区别就是不使用集中式的目录服务器，而是使用洪泛法在大量 Gnutella 用户之间进行查询。<br>为了不使查询的通信量过大，Gnutella 设计了一种有限范围的洪泛查询。这样可以减少倾注到互联网的查询流量</p>
<h3 id="全分布式结构的-P2P-电骡-eMule"><a href="#全分布式结构的-P2P-电骡-eMule" class="headerlink" title="全分布式结构的 P2P 电骡 eMule"></a>全分布式结构的 P2P 电骡 eMule</h3><p>电骡 eMule 使用分散定位和分散传输技术，把每一个文件划分为许多小文件块，并使用多源文件传输协议 MFTP 进行传送。因此用户可以同时从很多地方下载一个文件中的不同文件块。由于每一个文件块都很小，并且是并行下载，所以下载可以比较快地完成</p>
<h3 id="使用-P2P-的比特洪流-BT"><a href="#使用-P2P-的比特洪流-BT" class="headerlink" title="使用 P2P 的比特洪流 BT"></a>使用 P2P 的比特洪流 BT</h3><p>BitTorrent 所有对等方集合称为一个洪流 (torrent)，下载文件的数据单元为长度固定的文件块 (chunk)。基础设施结点，叫做追踪器 (tracker)。</p>
<p>当一个新的对等方 A 加入洪流时，追踪器就随机地从参与的对等方集合中选择若干个（例如，30 个），并把这些对等方的 IP 地址告诉 A。于是 A 就和这些对等方建立了 TCP 连接。所有与 A 建立了 TCP 连接的对等方为“相邻对等方”(neighboring peers)。<br>A 使用最稀有的优先 (rarest first) 的技术，首先向其相邻对等方请求对应的文件块。<br>凡当前以最高数据率向 A 传送文件块的某相邻对等方，A 就优先把所请求的文件块传送给该相邻对等方。</p>
<p>现在广泛使用的索引和查找技术叫做分布式散列表 DHT (Distributed Hash Table)。DHT 也可译为分布式哈希表，它是由大量对等方共同维护的散列表。</p>
<img src="/2021/03/11/ComputerNetwork7/10.png" class> 
<p><img src="/03/11/ComputerNetwork7/blog\blog\source\_posts\ComputerNetwork4\28.png" alt="image-20210310165232650"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/10/ComputerNetwork5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/10/ComputerNetwork5/" itemprop="url">运输层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-10T08:08:06+08:00">
                2021-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.5k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>传输层提供了主机应用程序进程之间的端到端的服务。实现了分用与复用。进行了报文差错计算。</p>
<p>只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 </p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\1.png" alt="image-20210310081042765"></p>
<img src="/2021/03/10/ComputerNetwork5/1.png" class>
<p>在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。即复用 (multiplexing)和分用 (demultiplexing)。</p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\2.png" alt="image-20210310081225873"></p>
<img src="/2021/03/10/ComputerNetwork5/2.png" class>
<p>根据应用程序的不同需求，运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP 。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 </p>
<h2 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h2><p>(1) 用户数据报协议 UDP (User Datagram Protocol)，提供无连接服务。在传送数据之前不需要先建立连接。传送的数据单位协议是 UDP 报文。对方的运输层在收到 UDP 报文后，不需要给出任何确认。<br>(2) 传输控制协议 TCP (Transmission Control Protocol)，提供面向连接的服务。<br>传送的数据单位协议是 TCP 报文段 (segment)。<br>TCP 不提供广播或多播服务。</p>
<p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。</p>
<h2 id="TCP-IP-运输层端口"><a href="#TCP-IP-运输层端口" class="headerlink" title="TCP/IP 运输层端口"></a>TCP/IP 运输层端口</h2><p>端口用一个 16 位端口号进行标志。端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在互联网中，不同计算机的相同端口号是没有联系的。</p>
<p>因此两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。</p>
<p>(1) 服务器端使用的端口号<br>熟知端口，数值一般为 0~1023，应用层协议在服务器端的默认端口号，客户端进程的端口号是客户端进程任意临时指定的<br>登记端口号，数值为 1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。<br>(2) 客户端使用的端口号<br>又称为短暂端口号，数值为 49152~65535，留给客户进程选择暂时使用。<br>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 </p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\3.png" alt="image-20210310081924823"></p>
<img src="/2021/03/10/ComputerNetwork5/3.png" class>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能：复用和分用的功能；差错检测的功能</p>
<p>UDP 的主要特点 ：</p>
<ul>
<li>(1) UDP 是无连接的，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。也无连接状态。</li>
<li>(2) UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li>
<li>(3) UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。因此应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率</li>
<li>(4) UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 </li>
<li>(5) UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>(6) UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li>
</ul>
<img src="/2021/03/10/ComputerNetwork5/4.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\4.png" alt="image-20210310082646269"></p>
<p>伪首部只是为了计算校验和</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 是面向连接的运输层协议。每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。<br>TCP 提供可靠交付的服务。<br>TCP 提供全双工通信。<br>面向字节流<br>TCP 中的“流”(stream)指的是流入或流出进程的字节序列。<br>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</p>
<p>TCP与网络虚电路的区别在于，TCP报文段在传输层抽象的逻辑信道中传输，路由器不可见；而虚电路经过的交换节点都必须保存虚电路的状态信息，如果使用了虚电路，就无法提供无连接服务</p>
<img src="/2021/03/10/ComputerNetwork5/5.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\5.png" alt="image-20210310083344105"></p>
<p>TCP 不关心应用进程一次把多长的报文发送到 TCP 缓存。TCP 对连续的字节流进行分段，形成 TCP 报文段。TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 </p>
<p>TCP 连接的端点叫做套接字 (socket) 或插口。端口号拼接到 IP 地址即构成了套接字。每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。</p>
<h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><img src="/2021/03/10/ComputerNetwork5/7.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\7.png" alt="image-20210310091000730"></p>
<h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4><img src="/2021/03/10/ComputerNetwork5/6.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\6.png" alt="image-20210310083731050"></p>
<h4 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h4><p>B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。<br>A 为每一个已发送的分组都设置了一个超时计时器。A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。</p>
<p>若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。<br>假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：<br>第一，丢弃这个重复的分组 M1，不向上层交付。<br>第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认</p>
<p>若传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。<br>A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。<br>B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。</p>
<h3 id="自动重传请求-ARQ"><a href="#自动重传请求-ARQ" class="headerlink" title="自动重传请求 ARQ"></a>自动重传请求 ARQ</h3><p>自动重传请求 ARQ  (Automatic Repeat reQuest)。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>之前的停止等待协议属于自动重传请求ARQ</p>
<h3 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h3><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。<br>流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。</p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\8.png" alt="image-20210310091136698"></p>
<img src="/2021/03/10/ComputerNetwork5/8.png" class>
<h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h3><p>发送方维持发送窗口，窗口的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。<br>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p>
<p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。优点：容易实现，即使确认丢失也不必重传。缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<p>这种协议又称为回退N（Go-back-N）</p>
<h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p>一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。<br>TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。</p>
<img src="/2021/03/10/ComputerNetwork5/9.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\9.png" alt="image-20210310091523302"></p>
<p>序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 </p>
<p>确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 </p>
<p>窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</p>
<h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><img src="/2021/03/10/ComputerNetwork5/10.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\10.png" alt="image-20210310091818706"></p>
<p>为了选择重传时间，TCP采用了自适应算法: </p>
<p>新的RTTS  = (1-<script type="math/tex">\alpha</script>) <em> (旧的RTTS) +<script type="math/tex">\alpha</script></em> (新的RTT样本)                           </p>
<p>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就重新计算一次</p>
<img src="/2021/03/10/ComputerNetwork5/11.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\11.png" alt="image-20210310093156162"></p>
<p>因此使用修正的 Karn 算法 ，报文段每重传一次，就把 RTT 增大一些，一般将RTT修正为之前的两倍</p>
<h3 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h3><p>若接受方接受到的数据字节流序号不连续且缺少某些序号，如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。</p>
<p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。<br>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。</p>
<h2 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h2><p>流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 </p>
<img src="/2021/03/10/ComputerNetwork5/12.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\12.png" alt="image-20210310102631435"></p>
<p>这可能发生死锁：B 向 A 发送了零窗口的报文段。之后B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p>
<p>为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。若窗口不是零，则死锁的僵局就可以打破了。 </p>
<p>可以用不同的机制来控制 TCP 报文段的发送时机:</p>
<p>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。<br>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push)操作。<br>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段发送出去。</p>
<h2 id="发送与接受方的传输策略"><a href="#发送与接受方的传输策略" class="headerlink" title="发送与接受方的传输策略"></a>发送与接受方的传输策略</h2><p>若发送方 TCP 每次接收到一字节的数据后就发送，这样，发送一个字节需要形成 41 字节长的 IP 数据报。若接收方确认，就需回送一个ACK。效率很低。会造成效率较低，可使用Nagle算法</p>
<p>Nagle算法：</p>
<p>若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。<br>当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。<br>只有在收到对前一个报文段的确认后才继续发送下一个报文段。<br>当到达的数据已达到报文段的最大长度时，就立即发送。</p>
<p>这样可以降低ACK次数，同时降低重传导致的效率下降</p>
<p>若接收方的应用进程每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。效果</p>
<p>解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。</p>
<h2 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h2><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。</p>
<p>增大资源不一定解决拥塞：例如增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞。</p>
<h3 id="拥塞控制与流量控制"><a href="#拥塞控制与流量控制" class="headerlink" title="拥塞控制与流量控制"></a>拥塞控制与流量控制</h3><p>拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 </p>
<p>而流量控制往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）。所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </p>
<img src="/2021/03/10/ComputerNetwork5/13.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\13.png" alt="image-20210310104619646"></p>
<h3 id="开环控制和闭环控制"><a href="#开环控制和闭环控制" class="headerlink" title="开环控制和闭环控制"></a>开环控制和闭环控制</h3><p>开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。<br>闭环控制方法是基于反馈环路的概念。属于闭环控制的有以下几种措施：<br>(1) 监测网络系统以便检测到拥塞在何时、何处发生。<br>(2) 将拥塞发生的信息传送到可采取行动的地方。<br>(3) 调整网络系统的运行以解决出现的问题。</p>
<h3 id="拥塞的指标"><a href="#拥塞的指标" class="headerlink" title="拥塞的指标"></a>拥塞的指标</h3><p>主要指标有：<br>由于缺少缓存空间而被丢弃的分组的百分数；<br>平均队列长度；<br>超时重传的分组数；<br>平均分组时延；<br>分组时延的标准差，等等。</p>
<h3 id="TCP-的拥塞控制方法"><a href="#TCP-的拥塞控制方法" class="headerlink" title="TCP 的拥塞控制方法"></a>TCP 的拥塞控制方法</h3><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。<br>TCP发送方维持一个拥塞窗口 CWND (Congestion Window)<br>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<br>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。<br>所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：min(公告窗口值，拥塞窗口值)</p>
<h3 id="判断拥塞"><a href="#判断拥塞" class="headerlink" title="判断拥塞"></a>判断拥塞</h3><p>重传定时器超时：现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于 1 %）。只要出现了超时，就可以猜想网络出现了拥塞。<br>收到三个相同（重复）的 ACK：个别报文段会在网络中丢失，预示可能会出现拥塞（实际未发生拥塞），因此可以尽快采取控制措施，避免拥塞。</p>
<h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p>慢开始 ：由小到大逐渐增大拥塞窗口数值。初始拥塞窗口 cwnd 不超过2至4个发送方的最大报文段SMSS的数值。在每收到一个对新的报文段的确认后（一个传输轮次 transmission round），可以把拥塞窗口增加，一般是加倍，直到到达慢开始门限值ssthresh </p>
<p>一个传输轮次 (transmission round)，也即往返时间RTT。例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。</p>
<p>拥塞避免阶段：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就执行慢开始算法</p>
<img src="/2021/03/10/ComputerNetwork5/14.png" class>![image-20210310105641866](D:\blog\blog\source\_posts\ComputerNetwork5\14.png)

如上图，当拥塞窗口 cwnd = 24 时，网络出现了超时（图中的点2），发送方判断为网络拥塞。于是调整门限值 ssthresh = cwnd / 2 = 12，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。

快重传算法：发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不会误认为出现了网络拥塞。因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法。

因此，如上图点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值ssthresh = cwnd / 2 = 8，同时设置拥塞窗口cwnd = ssthresh = 8，并开始执行拥塞避免算法。

<img src="/2021/03/10/ComputerNetwork5/15.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\15.png" alt="image-20210310110201209"></p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\16.png" alt="image-20210310110525642"></p>
<img src="/2021/03/10/ComputerNetwork5/16.png" class>
<h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><h3 id="运输连接"><a href="#运输连接" class="headerlink" title="运输连接"></a>运输连接</h3><p>TCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)，被动等待连接建立的应用进程叫做服务器(server)。</p>
<img src="/2021/03/10/ComputerNetwork5/17.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\17.png" alt="image-20210310110927241"></p>
<p>三次握手：</p>
<p>A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</p>
<p>B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x +1，自己选择的序号 seq = y。</p>
<p>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。A 的 TCP 通知上层应用进程，连接已经建立。B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程TCP 连接已经建立。</p>
<h3 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h3><p>四报文握手</p>
<img src="/2021/03/10/ComputerNetwork5/18.png" class>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\18.png" alt="image-20210310111200242"></p>
<p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。</p>
<p>B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。</p>
<p>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/08/ComputerNetwork4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/08/ComputerNetwork4/" itemprop="url">网络层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-08T11:09:47+08:00">
                2021-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.3k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="网络层的两种服务"><a href="#网络层的两种服务" class="headerlink" title="网络层的两种服务"></a>网络层的两种服务</h2><p>分为虚电路与数据报服务</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\1.png" alt="image-20210308172515362"></p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\2.png" alt="image-20210308172552204"></p>
<img src="/2021/03/08/ComputerNetwork4/1.png" class>
<img src="/2021/03/08/ComputerNetwork4/2.png" class>
<p>网络层提供简单灵活的、无连接的、尽最大努力交付的数据报服务。将可靠网络传输交给传输层。无需建立连接。每一个分组（即 IP 数据报）独立发送。</p>
<p>这样使得网络的造价很低且灵活</p>
<h2 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h2><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有三个协议：地址解析协议 ARP(Address Resolution Protocol)网际控制报文协议 ICMP(Internet Control Message Protocol)网际组管理协议 IGMP(Internet Group Management Protocol)</p>
<img src="/2021/03/08/ComputerNetwork4/3.png" class>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\3.png" alt="image-20210308172812821"></p>
<p>IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符（ipv4）</p>
<img src="/2021/03/08/ComputerNetwork4/4.png" class>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\4.png" alt="image-20210308172921724"></p>
<p>点分十进制记法 </p>
<img src="/2021/03/08/ComputerNetwork4/5.png" class>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\5.png" alt="image-20210308173017699"></p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\6.png" alt="image-20210308173125225"></p>
<img src="/2021/03/08/ComputerNetwork4/6.png" class>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\7.png" alt="image-20210308173313667"></p>
<p>在同一个局域网上的主机或路由器的IP 地址中的网络号必须是一样的。路由器总是具有两个或两个以上的 IP 地址。路由器的每一个接口都有一个不同网络号的 IP 地址。两个路由器直接相连的接口处，可指明也可不指明 IP 地址。如指明 IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” 。</p>
<h2 id="IP-地址与硬件地址"><a href="#IP-地址与硬件地址" class="headerlink" title="IP 地址与硬件地址"></a>IP 地址与硬件地址</h2><p>硬件地址（或物理地址）是数据链路层和物理层使用的地址</p>
<p>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\8.png" alt="image-20210308173851627"></p>
<img src="/2021/03/08/ComputerNetwork4/8.png" class>
<img src="/2021/03/08/ComputerNetwork4/9.png" class>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\9.png" alt="image-20210308212359972"></p>
<p>每一个主机都设有一个 ARP 高速缓存 (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p>
<p>&lt; IP address；MAC address；TTL &gt;TTL (Time To Live)：地址映射有效时间 </p>
<p>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。<br>如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。如没有， ARP 进程在本局域网上广播发送一个 ARP 请求分组。收到 ARP 响应分组后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。ARP看到了IP地址，因此工作在网络层</p>
<p>调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的.</p>
<p>具体来说：</p>
<p>发送方是主机/路由器，发送到本网络另一个主机，只需直接查询ARP；发送到另一网络主机，用ARP找到本网络上一个路由器的地址，然后剩下工作让路由器处理</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\10.png" alt="image-20210308215026552"></p>
<img src="/2021/03/08/ComputerNetwork4/10.png" class>
<p>IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。因为增加开销，所以实际上这些选项很少被使用。</p>
<p>路由表没有给分组指明到某个网络的完整路径。路由表指出，到某个网络应当先到某个路由器（即下一跳路由器）。在到达下一跳路由器后，再继续查找其路由表，直到再下一步应当到哪一个路由器。这样一步一步地查找下去，直到最后到达目的网络。</p>
<h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。<br>从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\11.png" alt="image-20210309125940012"></p>
<img src="/2021/03/08/ComputerNetwork4/11.png" class>
<p>减少了 IP 地址的浪费；使网络的组织更加灵活；更便于维护和管理</p>
<p>从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码(subnet mask)可以找出 IP 地址中的子网部分。  </p>
<p>子网掩码长度＝32位。某位＝1：IP地址中的对应位为网络号和子网号。某位＝0：IP地址中的对应位为主机号</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\12.png" alt="image-20210309130210263"></p>
<img src="/2021/03/08/ComputerNetwork4/12.png" class>
<p>数据报的首部并没有提供子网掩码的信息。因此分组转发的算法也必须做相应的改动</p>
<p>(1) 从收到的分组的首部提取目的 IP 地址 D。<br>(2) 先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行 (3)。<br>(3) 若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行 (4)。<br>(4) 对路由表中的每一行，将子网掩码和 D 逐位相“与”。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行 (5)。<br>(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行 (6)。<br>(6) 报告转发分组出错。</p>
<h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。</p>
<p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\13.png" alt="image-20210309130717073"></p>
<img src="/2021/03/08/ComputerNetwork4/13.png" class>
<p>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 </p>
<p>差错报告报文共有 4 种 ：终点不可达；时间超过；参数问题；改变路由（重定向）</p>
<p>询问报文有2种 ：回送请求和回答报文；时间戳请求和回答报文</p>
<p>PING (Packet InterNet Groper) ：用来测试两个主机之间的连通性。 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。 </p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器是网络层设备，实现了网络模型的下三层</p>
<p>路由器的任务是连接不同的网络，完成分组转发和路由计算（包括路由表维护）</p>
<p>在同一个网络内部转发无需路由器，否则需要（连接同构网络倒是可以使用交换机）</p>
<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>不存在一种绝对的最佳路由算法。所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</p>
<ul>
<li>内部网关协议 IGP (Interior Gateway Protocol)<br>在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li>
<li>外部网关协议 EGP (External Gateway Protocol)<br>若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。  </li>
</ul>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>一般来说，路由表有4个项目：目的网络ip，子网掩码，下一跳IP地址，接口</p>
<h3 id="转发表"><a href="#转发表" class="headerlink" title="转发表"></a>转发表</h3><p>转发表是油路由表得到的，含有一个分组将发往的目的地址，以及分组的下一跳。为了减少重复的项目，可以用默认路由代替所有具有相同下一跳的项目</p>
<p>转发与路由选择的区别：转发只涉及1个路由器，把收到的IP数据报从合适的端口转发出去；路由选择涉及很多路由器，路由表是协同工作的结果</p>
<h3 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP"></a>内部网关协议 RIP</h3><p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。</p>
<p>从一个路由器到直接连接的网络的距离定义为 1。从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。RIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1。这里的“距离”实际上指的是“最短距离”。 RIP 允许一条路径最多只能包含 15 个路由器（防止环路）。“距离”的最大值为 16 时即相当于不可达。可见 RIP 只适用于小型互联网。RIP不支持子网掩码的RIP广播，因此RIP中每个网络的子网掩码必须相同</p>
<p>RIP只与相邻路由器交换信息，交换当前路由器所知道的全部信息</p>
<p>RIP默认在使用RIP的路由器之间每30秒广播一次RIP路由更新情况</p>
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\14.png" alt="image-20210309131937214"></p>
<img src="/2021/03/08/ComputerNetwork4/14.png" class>
<p>RIP协议特点：好消息传播得快，坏消息传播得慢。</p>
<h3 id="内部网关协议-OSPF"><a href="#内部网关协议-OSPF" class="headerlink" title="内部网关协议 OSPF"></a>内部网关协议 OSPF</h3><p>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。<br>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。  </p>
<p>如果到同一个网络有多条代价相同的路径，可以将通信量分配给这几条路径，形成负载平衡</p>
<p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过 200 个。  </p>
<p>OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF  协议要比距离向量协议 RIP 好得多。</p>
<img src="/2021/03/08/ComputerNetwork4/15.png" class> 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\15.png" alt="image-20210309132858732"></p>
<p>OSPF共有以下五种分组类型:</p>
<p>(1)类型1，问候(Hello)分组，用来发现和维持邻站的可达性。通常10秒就要交换一次问候分组</p>
<p>(2)类型2，数据库描述(Database DescriPtion)分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。刚开始工作时会使用，与相邻路由器交换信息</p>
<p>(3)类型3，链路状态请求(Link State Request)分组，向对方请求发送某些链路状态项目的详细信息。</p>
<p>(4)类型4，链路状态更新(Link State Update)分组，用洪泛法对全网更新链路状态</p>
<p>(5)类型5，链路状态确认(Link State Acknowledgment)分组，对链路更新分组的确认。</p>
<p>刚开始工作时，数据库描述分组-》链路状态请求分组，这样建立了全网同步的链路数据库。只要一个路由器状态变化，他就使用链路状态更新分组，其他路由器更新后发送链路状态确认分组。OSPF规定没隔一段时间就刷新一次数据库内的链路状态</p>
<h3 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h3><p>BGP 是不同自治系统的路由器之间交换路由信息的协议。 </p>
<p>边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。  </p>
<p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人” (BGP speaker) 。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的。 BGP 发言人之间要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。所有发言人都交换网络可达性的信息（即到达某个网络所要经过的一系列AS）后，各BGP发言人就可找到到达各个自治系统的较好路由</p>
<p>BGP发言人除必须运行BGP外，还必须运行该AS所用的内部网关协议，如OSPF</p>
<img src="/2021/03/08/ComputerNetwork4/16.png" class> 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\16.png" alt="image-20210309133101599"></p>
<p>BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。</p>
<p>BGP使用四种报文：</p>
<p>打开open，用来与相邻的发言人建立关系</p>
<p>更新update，用来发送某一路由的信息，以及列出要撤销的多条路由</p>
<p>keepalive，确认呢打开报文并周期性证实邻站关系</p>
<p>notification，发送检测到的差错</p>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><img src="/2021/03/08/ComputerNetwork4/17.png" class> 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\17.png" alt="image-20210309133544333"></p>
<p>IPv6 引进的主要变化：</p>
<p>更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。<br>扩展的地址层次结构。<br>灵活的首部格式。 IPv6 定义了许多可选的扩展首部。<br>改进的选项。 IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。<br>允许协议继续扩充。<br>支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。<br>支持资源的预分配。</p>
<img src="/2021/03/08/ComputerNetwork4/18.png" class> 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\18.png" alt="image-20210309133720614"></p>
<p>IPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并将扩展首部留给路径两端的源站和目的站的主机来处理。数据报途中经过的路由器都不处理这些扩展首部（只有一个首部例外，即逐跳选项扩展首部）。这样就大大提高了路由器的处理效率。</p>
<img src="/2021/03/08/ComputerNetwork4/19.png" class>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\19.png" alt="image-20210309133906239"></p>
<p>IPv6 数据报的目的地址可以是以下三种基本类型地址之一：<br>(1) 单播 (unicast)：传统的点对点通信。<br>(2) 多播 (multicast)：一点对多点的通信。<br>(3) 任播 (anycast)：这是 IPv6 增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交付其中的一个，通常是距离最近的一个。 </p>
<p>IPv6 使用冒号十六进制记法(colon hexadecimal notation, 简写为colon hex)。<br>每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如：<br>68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF<br>在十六进制记法中，允许把数字前面的0省略。例如把0000中的前三个0省略，写成1个0。</p>
<p>冒号十六进制记法可以允许零压缩 (zero compression)，即一连串连续的零可以为一对冒号所取代。FF05:0:0:0:0:0:0:B3  可压缩为FF05::B3</p>
<h3 id="从-IPv4-向-IPv6-过渡"><a href="#从-IPv4-向-IPv6-过渡" class="headerlink" title="从 IPv4 向 IPv6 过渡"></a>从 IPv4 向 IPv6 过渡</h3><p>IPv6 过渡只能采用逐步演进的办法，同时，还必须使新安装的 IPv6 系统能够向后兼容：IPv6 系统必须能够接收和转发 IPv4 分组，并且能够为 IPv4 分组选择路由</p>
<h4 id="双协议栈"><a href="#双协议栈" class="headerlink" title="双协议栈"></a>双协议栈</h4><img src="/2021/03/08/ComputerNetwork4/20.png" class>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\20.png" alt="image-20210309135026264"></p>
<h4 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h4><img src="/2021/03/08/ComputerNetwork4/21.png" class>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\21.png" alt="image-20210309135157722"></p>
<p>IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6</p>
<img src="/2021/03/08/ComputerNetwork4/22.png" class>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\22.png" alt="image-20210309135302904"></p>
<h2 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h2><img src="/2021/03/08/ComputerNetwork4/23.png" class>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\23.png" alt="image-20210309135525175"></p>
<p>IP 多播所传送的分组需要使用多播 IP 地址。多播组的标识符就是 IP 地址中的 D 类地址</p>
<p>多播数据报和一般的 IP 数据报的区别就是它使用 D 类 IP 地址作为目的地址，并且首部中的协议字段值是2，表明使用网际组管理协议 IGMP。多播数据报也是“尽最大努力交付”，不保证一定能够交付多播组内的所有成员。对多播数据报不产生 ICMP 差错报文。因此，若在 PING 命令后面键入多播地址，将永远不会收到响应。</p>
<h3 id="网际组管理协议-IGMP"><a href="#网际组管理协议-IGMP" class="headerlink" title="网际组管理协议 IGMP"></a>网际组管理协议 IGMP</h3><p>IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机参加或退出了某个多播组。</p>
<p>IGMP 可分为两个阶段 </p>
<p>第一阶段：加入多播组。<br>当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。<br>本地的多播路由器收到 IGMP 报文后，将组成员关系转发给互联网上的其他多播路由器。</p>
<p>第二阶段：探询组成员变化情况。<br>因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。<br>只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。<br>但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。</p>
<img src="/2021/03/08/ComputerNetwork4/24.png" class>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\24.png" alt="image-20210309140942875"></p>
<p>一个多播组中的成员是动态变化的，随时会有主机加入或离开这个多播组。多播路由选择实际上就是要找出以源主机为根结点的多播转发树。</p>
<p>多播路由选择协议在转发多播数据报时使用三种方法</p>
<h4 id="洪泛与剪除"><a href="#洪泛与剪除" class="headerlink" title="洪泛与剪除"></a>洪泛与剪除</h4><p>这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。</p>
<p>一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。为了避免兜圈子，采用反向路径广播策略。 先检查它是否是从源点经最短路径传送来的。若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就丢弃而不转发。</p>
<p>多播转发树上的路由器发现它的下游树枝已没有多播组的成员，就把它和下游树枝一起剪除。</p>
<h4 id="隧道技术-1"><a href="#隧道技术-1" class="headerlink" title="隧道技术"></a>隧道技术</h4><img src="/2021/03/08/ComputerNetwork4/25.png" class>  
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\25.png" alt="image-20210309141337873"></p>
<h4 id="基于核心的发现技术"><a href="#基于核心的发现技术" class="headerlink" title="基于核心的发现技术"></a>基于核心的发现技术</h4><p>这种方法是对每一个多播组 G 指定一个核心(core) 路由器，给出它的 IP 单播地址。<br>核心路由器创建出对应于多播组 G 的转发树。 </p>
<h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。</p>
<p>利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网VPN (Virtual Private Network)。“专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。</p>
<img src="/2021/03/08/ComputerNetwork4/26.png" class> 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\26.png" alt="image-20210309145134833"></p>
<h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>装有 NAT 软件的路由器叫作 NAT路由器，它至少有一个有效的外部全球IP地址。<br>所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接。  </p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网 (plug-and-play networking) 的机制。<br>这种机制允许一台计算机加入新的网络和获取IP 地址而不用手工参与。</p>
<p>DHCP 中继代理以单播方式转发发现报文 </p>
<img src="/2021/03/08/ComputerNetwork4/27.png" class> 
<p><img src="/03/08/ComputerNetwork4/blog\blog\source\_posts\ComputerNetwork4\27.png" alt="image-20210310163732725"></p>
<p>DHCP 协议是基于UDP层之上的应用，dhcp使用udp携带报文，udp封装在ip数据包中发送</p>
<p><a href="http://www.023wg.com/message/message/cd_feature_dhcp_message_format.html" target="_blank" rel="noopener">http://www.023wg.com/message/message/cd_feature_dhcp_message_format.html</a></p>
<p>DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。<br>租用期的数值应由 DHCP 服务器自己决定。<br>DHCP 客户也可在自己发送的报文中（例如，发现报文）提出对租用期的要求。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/07/ComputerNetwork3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/07/ComputerNetwork3/" itemprop="url">数据链路层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-07T15:07:12+08:00">
                2021-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据链路层的主要作用是如何将数据可靠地传输到相邻节点</p>
<p>数据链路层使用的信道主要有以下两种类型:</p>
<p>点对点信道。这种信道使用一对一的点对点通信方式。<br>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。 </p>
<h2 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h2><p>物理链路 (link) 是一条点到点的物理线路段，中间没有任何其他的交换结点。除了物理线路外，还必须有通信协议来进行传输控制。软件+硬件形成了数据链路</p>
<p>目前最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能</p>
<h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a><strong>三个基本问题</strong></h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a><strong>封装成帧</strong></h3><p>封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\4.png" alt="image-20210307171441510"></p>

<p>当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符。控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT (End Of Transmission) 表示帧的结束。</p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a><strong>透明传输</strong></h3><p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\5.png" alt="image-20210307171643848"></p>
<img src="/2021/03/07/ComputerNetwork3/5.png" class>
<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a><strong>差错检测</strong></h3><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER </p>
<p>误码率与信噪比有很大的关系</p>
<h4 id="循环冗余检验-CRC"><a href="#循环冗余检验-CRC" class="headerlink" title="循环冗余检验 CRC"></a><strong>循环冗余检验</strong> <strong>CRC</strong></h4><p>假设待传送的一组数据 M ，k位，冗余码n位。 M 后面添加 n 个 0。得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，R 是 n 位 。 将余数 R 作为冗余码拼接在数据 M 后面发送出去。</p>
<h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><p>不但要提醒出现问题，最好能够定位</p>
<p>常见方法是海明码</p>
<p><a href="https://www.cnblogs.com/godoforange/p/12003676.html" target="_blank" rel="noopener">https://www.cnblogs.com/godoforange/p/12003676.html</a></p>
<h2 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h2><p>之所以分组，是为了在出错时只需要重发出错的帧，提高效率</p>
<p>组帧时需要首尾都有，因为网络中信息是以帧为最小单位进行传输的。而分组（IP数据报）包含在帧的数据部分内，因此无需尾部定界</p>
<p>为了实现组帧分界，有以下方法：</p>
<ul>
<li>字符计数法：帧头部表明帧内字符数</li>
<li>字符填充：见下文</li>
<li>零比特填充：见下文</li>
<li>违规编码：采用违规电平对</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><p>每次只允许一帧，然后下一帧</p>
<h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><h4 id="后退N帧"><a href="#后退N帧" class="headerlink" title="后退N帧"></a>后退N帧</h4><p>发送窗口不为1，接受窗口为1，每次收到确认帧，发送窗口前移一帧</p>
<p>确认帧不一定连续，可以收到几个帧之后发送最后的接受帧号</p>
<p>接受端只按序接受，如果中间隔帧即使收到的顺序正确也会全部丢弃</p>
<p>不一定优于停止-等待协议</p>
<h4 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h4><p>发送窗口与接受窗口均不为1</p>
<p>如果计时器超时或者接收到否定帧NAK都会重传</p>
<p>为了保证接受方移动后新旧窗口没有重叠，如果采用n比特对帧编号，需要：接收窗口+发送窗口&lt;=<script type="math/tex">2^n</script>。不然会出错（可以考虑n=3，接受窗口为1的情况，重传的8个帧与新的8个帧编号相同）</p>
<p>一般情况下，接受与发送窗口大小相同</p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>局域网的协议一般在数据链路层和物理层，而广域网在网络层</p>
<p>PPP与HDLC是常见的两种广域网数据链路层控制协议</p>
<h3 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h3><p><a href="https://www.cnblogs.com/chaguang/p/8097967.html" target="_blank" rel="noopener">https://www.cnblogs.com/chaguang/p/8097967.html</a></p>
<p>应用在直接相连两个节点的链路上</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\6.png" alt="image-20210307172929508"></p>
<img src="/2021/03/07/ComputerNetwork3/6.png" class>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\17.png" alt="image-20210307201128536"></p>
<img src="/2021/03/07/ComputerNetwork3/17.png" class>
<p>PPP协议是一种在串行链路上传输IP数据包的一种方法，是一个协议的集合，不是单一的协议，支持建立链路的链路控制协议LCP以及一系列的NCP</p>
<p>PPP帧如下所示</p>
<img src="/2021/03/07/ComputerNetwork3/7.png" class>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\7.png" alt="image-20210307173038517"></p>
<p>为实现透明传输，当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充；当 PPP 用在异步传输时，就使用一种特殊的字符填充法。 </p>
<img src="/2021/03/07/ComputerNetwork3/7.png" class>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\8.png" alt="image-20210307173358468"></p>
<img src="/2021/03/07/ComputerNetwork3/8.png" class>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\9.png" alt="image-20210307174107549"></p>
<img src="/2021/03/07/ComputerNetwork3/9.png" class>
<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><p>高级链路层协议（HDLC）面向比特（PPP面向字节），不依赖于任何一种字符编码集；数据报文可透明传输，用0比特插入法；全双工；采用CRC校验</p>
<p>适用于非平衡配置（一个主站控制其他所有）与平衡配置（链路两端是平等的复合站）</p>
<p>HDLC有三种站：主站（控制链路，发出 命令帧）；从站（受控于主站，发出 响应帧）；复合站</p>
<p>HDLC有三种数据操作方式：</p>
<ul>
<li>正常响应：主站命令，从站相应</li>
<li>异步平衡：每个复合站都可以进行数据传输</li>
<li>异步相应：从站未收到主站命令，也可以相应</li>
</ul>
<p><a href="http://www.023wg.com/message/message/cd_feature_hdlc_frame.html" target="_blank" rel="noopener">http://www.023wg.com/message/message/cd_feature_hdlc_frame.html</a></p>
<h2 id="介质控制访问"><a href="#介质控制访问" class="headerlink" title="介质控制访问"></a>介质控制访问</h2><p>隔离来自同一信道的其他节点的信号</p>
<h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><p>多路复用，比如频分/时分/波分/码分 复用</p>
<h3 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h3><p>既不共享时间，也不共享空间</p>
<p>有ALOHA/CSMA等协议</p>
<h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><p>纯ALOHA：不检测直接发送，如果没有收到确认说明冲突了，重新发送</p>
<p>时隙ALOHA：只有时隙的开始才能够发送，时隙的程度使得帧可以正好发送完毕</p>
<h3 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h3><p>令牌传递</p>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网最重要的特征就是具有广播功能</p>
<p>局域网主要的特点有：所有站点平等，能够广播和组播，较低时延就较高的总带宽</p>
<p>数据链路层可以拆成逻辑链路控制子层LLC与媒体介入控制子层MAC，后者提供对物理层的统一访问接口；前者为网络层提供服务接口</p>
<p>三种特殊的局域网：</p>
<ul>
<li>以太网，目前应用最普遍的局域网技术，逻辑拓扑为总线形，实际可以为星形或拓展星形</li>
<li>令牌网，逻辑环形，实际星形</li>
<li>光纤分布数字接口FDDI，逻辑环形，实际双环结构</li>
</ul>
<p>IEEE802.3局域网可以简称为以太网，它与DIX Ethernet V2标准差别微小</p>
<p>计算机与外界的连接通过网络接口板（网卡），装有处理器和控制器，实现帧的控制与交换等，具有全球唯一的一个代码MAC地址</p>
<p>IEEE802.11是无线局域网的一系列协议，制定了MAC层协议，采用CSMA/CA协议进行介质访问控制。在无线局域网中发送过程中碰撞也要继续传递直到帧传递完全；有线会直接停止</p>
<p>无线局域网可以分为</p>
<ul>
<li>固定基础设施无线局域网：无线局域网的最小构建是基本服务集（BBS），所有的站在本BBS内都可以直接通信，对站外需要经过接入点（AP），AP作用类似网桥。一个BBS可以是孤立的，也可以通过AP连接到主干分配系统DS再接入另一个基本服务集，形成扩展的服务集。也可以通过门桥接入其他类型的无线局域网</li>
<li>无固定基础设施无线局域网自组织网络：没有AP，各移动站状态平等，中间节点都为转发节点且有路由器功能</li>
</ul>
<h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a><strong>CSMA/CD</strong> <strong>协议</strong></h3><p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\10.png" alt="image-20210307175016131"></p>
<img src="/2021/03/07/ComputerNetwork3/10.png" class>
<p>CSMA/CD 含义：载波监听多点接入 / 碰撞检测  </p>
<p>一般用于总线型以太网</p>
<p>协议要点：</p>
<p>(1) 准备发送。<br>(2) 检测信道。若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。<br>(3) 检查碰撞。在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里只有两种可能性：<br>①发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到 (1)。<br>②发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 (2)，继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\11.png" alt="image-20210307175435098"></p>
<img src="/2021/03/07/ComputerNetwork3/11.png" class>
<p>1990年 IEEE 制定出星形以太网 10（速率10M/s）BASE（基带）-T（双绞线） 的标准 802.3i，之后以太网也就在局域网中占据了统治地位</p>
<p>集线器/路由器/交换机与冲突域/广播域： <a href="https://blog.csdn.net/gui951753/article/details/79402528" target="_blank" rel="noopener">https://blog.csdn.net/gui951753/article/details/79402528</a></p>
<p>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。<br>集线器很像一个多接口的转发器</p>
<p>多个站在以太网工作时可能会发生碰撞。假设$\zeta$是以太网单程端到端传播时延。则争用期（冲突窗口期）长度为 2$\zeta$，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。 </p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\12.png" alt="image-20210307181219914"></p>
<img src="/2021/03/07/ComputerNetwork3/12.png" class>
<p>如果发送端在2$\zeta$内没有收到干扰信号，那么之后也不会收到干扰信号，因为并没有其他端口回复干扰。因此最小帧长为2$\zeta$*发送速率。如果收到一个帧长更小的帧，说明没有传完就被打断，直接丢弃</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\13.png" alt="image-20210307181713440"></p>
<img src="/2021/03/07/ComputerNetwork3/13.png" class>
<h3 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h3><p>用于无线区域网，无法碰撞检测</p>
<p>修改CSMA/CD协议，将碰撞检测改为碰撞避免。不仅要等待一个时间间隔，还要竞争窗口并随机退避时间。当检测到信道空闲且数据帧是要发送的第一个数据帧时才会发送</p>
<p>除此外还使用预约信道（通知其他站点自己传输的时长），ACK帧（发给发送方，如果收不到就要重传），RTS/CTS帧</p>
<h3 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h3><p>在局域网中，硬件地址又称为物理地址，或 MAC 地址。 MAC地址是局域网通信设备或端口的唯一标识符。 </p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\14.png" alt="image-20210307182034508"></p>
<img src="/2021/03/07/ComputerNetwork3/14.png" class>
<p>IEEE规定地址字段的第一字节的最低位为 I/G 位。I/G 表示 Individual / Group。当 I/G位=0 时，地址字段表示一个单站地址。当 I/G位=1 时，表示组地址，用来进行多播（以前曾译为组播）。所有 48 位都为 1 时，为广播地址。只能作为目的地址使用。</p>
<p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址。如果是传到本站的收下，否则丢弃</p>
<p>最常用的 MAC 帧是以太网 V2 的格式</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\15.png" alt="image-20210307182249428"></p>
<img src="/2021/03/07/ComputerNetwork3/15.png" class>
<p>类型字段用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\16.png" alt="image-20210307200703676"></p>
<img src="/2021/03/07/ComputerNetwork3/16.png" class>
<h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><p>使用集线器扩展。但是碰撞域也被增大了，且如果不同的碰撞域数据率不同，就无法连接起来</p>
<h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a><strong>在数据链路层扩展以太网</strong></h3><p>扩展以太网早期使用网桥，现在使用以太网交换机</p>
<p>网桥根据 MAC 帧的目的地址对收到的帧进行转发和过滤。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。 </p>
<p>根据路由选择算法不同，可以将网桥分为：</p>
<ul>
<li>透明网桥，通过自学习法</li>
<li>源路由网桥，路由选择由源站控制，原站发出发现帧，传递直到目的站，目的站发送应答帧，通过源路径返回，记录途径的网桥，然后源站就获得路径并选出最佳路由（往返时间最短）。之后再发送时必须要携带这一路由信息</li>
</ul>
<p>以太网交换机实质上就是一个多接口的网桥，每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。以太网交换机具有并行性，可以无碰撞地传输数据，并不会扩大碰撞域。不但隔离了冲突域，还通过VLAN隔离了广播域</p>
<p>以太网交换机的接口有存储器，能在输出端口繁忙时把到来的帧进行缓存。以太网交换机是一种即插即用设备，其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。以太网交换机使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。</p>
<p>目前以太网有直通（只检查目的地址，直接发送，不能支持不同速率的端口的交换）和存储转发（先缓存再检查帧是否出错，出错便丢弃，支持不同速率的端口的交换）两种交换模式</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\computerNetwork2\18.png" alt="image-20210307203457951"></p>
<img src="/2021/03/07/ComputerNetwork3/18.png" class>
<p>交换机收到一帧后先进行自学习。查找交换表中与收到帧的源地址有无相匹配的项目。<br>如没有，就在交换表中增加一个项目（源地址、进入的接口和有效时间）。<br>如有，则把原有的项目进行更新（进入的接口或有效时间）。<br>转发帧。查找交换表中与收到帧的目的地址有无相匹配的项目。<br>如没有，则向所有其他接口（进入的接口除外）转发。<br>如有，则按交换表中给出的接口进行转发。<br>若交换表中给出的接口就是该帧进入交换机的接口，则应丢弃这个帧（因为这时不需要经过交换机进行转发）</p>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</p>
<p>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为 VLAN 标记 (tag)，用来指明发送该帧的计算机属于哪一个虚拟局域网。插入 VLAN 标记得出的帧称为 802.1Q 帧 或 带标记的以太网帧。</p>
<p><img src="/03/07/ComputerNetwork3/blog\blog\source\_posts\ComputerNetwork3\19.png" alt="image-20210307204031653"></p>
<img src="/2021/03/07/ComputerNetwork3/19.png" class>
<p>如上图，B1广播时，只有B2和B3会接收到，其余成员不会</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/07/computerNetwork2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/07/computerNetwork2/" itemprop="url">网络层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-07T13:47:38+08:00">
                2021-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据流</p>
<p>信号具体怎样传递，存在着不同方式，其中需要经过调制等信号处理手段。传输时可能是数字信号，也可能是模拟信号。前者为离散信号，后者为连续信号。二者通过采样量化等手段可以相互转化</p>
<h2 id="通信的一些定义"><a href="#通信的一些定义" class="headerlink" title="通信的一些定义"></a>通信的一些定义</h2><p>码元是用一个固定时长（码元宽度）的信号波形表示一个k进制的数字，表示离散值的基本波形。比如二进制编码时就只有两种码元</p>
<p>码元传递效率即单位时间内能够传递码元的个数，也即脉冲个数活信号变化的次数，单位是波特，信息传递效率即k*码元传递效率</p>
<p>信道 —— 一般用来表示向某一个方向传送信息的媒体</p>
<p>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互</p>
<p>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)</p>
<p>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息</p>
<p>基带信号（即基本频带信号）—— 来自信源的信号，一般为低频不方便传输。通过调制时不同的载波，可以调制到不同的频段</p>
<h2 id="数字数据转化为数字信号"><a href="#数字数据转化为数字信号" class="headerlink" title="数字数据转化为数字信号"></a>数字数据转化为数字信号</h2><p>不归零制：不归零制：正电平代表 1，负电平代表 0。<br>归零制：正脉冲代表 1，负脉冲代表 0。<br>曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。<br>差分曼彻斯特编码：若为1，则前半电位与上一个码元后半电位相同，0则反之</p>
<p><img src="/03/07/computerNetwork2/blog\blog\source\_posts\computerNetwork2\1.png" alt="image-20210307140031047"></p>
<img src="/2021/03/07/computerNetwork2/1.png" class>
<h2 id="数字数据转化为模拟信号"><a href="#数字数据转化为模拟信号" class="headerlink" title="数字数据转化为模拟信号"></a>数字数据转化为模拟信号</h2><p>基本的调制方法：调幅（AM），随数字信号调节载波振幅；调频（FM）；调相（AM）</p>
<img src="/2021/03/07/computerNetwork2/1.png" class>
<p><img src="/03/07/computerNetwork2/blog\blog\source\_posts\computerNetwork2\2.png" alt="image-20210307140909735"></p>
<p>为了提高信息传递效率，可以采用混合调制的方法，比如正交振幅调制</p>
<h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p>信号传递的过程中会出现失真，也即信道内部存在噪声S，设信号为N，信噪比(dB) = 10 log10(S/N)    (dB) </p>
<p><img src="/03/07/computerNetwork2/blog\blog\source\_posts\computerNetwork2\3.png" alt="image-20210307142040963"></p>
<img src="/2021/03/07/computerNetwork2/3.png" class>
<p>因此若信噪比或带宽无限大时，理想传输速率无限大</p>
<h2 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h2><p>在没有噪声的情况下，因为码间干扰，理想低通信道的极限数据传输率为2WlogV，V为离散码元种类总数，W为低通信道的带宽</p>
<p>并不是香农定理的极限形式，只是从两个角度进行了分析</p>
<h2 id="物理层下的传输媒体"><a href="#物理层下的传输媒体" class="headerlink" title="物理层下的传输媒体"></a>物理层下的传输媒体</h2><p>这些传输媒体不属于物理层</p>
<p>可分为导引型（光缆）与非导引型（电磁波）</p>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a><strong>信道</strong>复用技术</h2><p>频分复用</p>
<p>时分复用</p>
<p>码分复用：每一个比特时间（发送1bit需要的时间）划分为 m 个短的间隔，称为码片，每个站被指派一个唯一的 m bit 码片序列。这样每个站点的发送数据率/频带宽度变成之前的m倍。码片之间必须各不相同且正交</p>
<h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><h3 id="ADSL-技术"><a href="#ADSL-技术" class="headerlink" title="ADSL 技术"></a>ADSL 技术</h3><p>用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。电话只使用了低频，这样高频就可以用来上网，带宽不对称</p>
<h3 id="DMT-技术"><a href="#DMT-技术" class="headerlink" title="DMT 技术"></a>DMT 技术</h3><p>同样是电话线，频分复用</p>
<h3 id="。。。"><a href="#。。。" class="headerlink" title="。。。"></a>。。。</h3><h2 id="电路交换-报文交换-分组交换"><a href="#电路交换-报文交换-分组交换" class="headerlink" title="电路交换/报文交换/分组交换"></a>电路交换/报文交换/分组交换</h2><p>电路交换：数据传输前两点间建立专用的通信道路，直到通信结束后释放</p>
<p>报文交换：无需链接，动态分配道路，数据交换的单位是报文，交换时存储转发</p>
<p>存储转发：以太网交换机的控制器先将输入端口到来的数据包缓存起来，先检查数据包是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。正因如此，存储转发方式在数据处理时延时大，这是它的不足，但是它可以对进入交换机的数据包进行错误检测，并且能支持不同速度的输入/输出端口间的交换，可有效地改善网络性能。它的另一优点就是这种交换方式支持不同速度端口间的转换，保持高速端口和低速端口间协同工作。实现的办法是将10Mbps低速包存储起来，再通过100Mbps速率转发到端口上。</p>
<p>分组交换：报文分组后的报文交换</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/07/ComputerNetwork1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/07/ComputerNetwork1/" itemprop="url">计算机网络概况</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-07T10:31:08+08:00">
                2021-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><strong>数据的传送速率</strong>，它也称为数据率(data rate)或比特率 (bit rate)。单位是bit/s，或 kbit/s等</p>
<p>速率往往是指额定速率或标称速率，非实际运行速率</p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>无线网络中，指<strong>信号具有的频带宽度</strong>，单位是HZ</p>
<p>有线网络中，指<strong>某通道传播数据的能力</strong>，单位是bit/s</p>
<p>前者是频域称谓，后者是时域称谓，本质是一样的。<strong>其本质是类似的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“数据率”也越高。</strong></p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a><strong>吞吐量</strong></h3><p><strong>在单位时间内通过某个网络（或信道、接口）的数据量</strong>，<strong>更经常地用于对现实世界中的网络的一种测量</strong></p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a><strong>时延</strong></h3><p><strong>是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间</strong></p>
<p>由以下几个不同的部分组成：</p>
<ol>
<li><strong>发送时延</strong></li>
<li><strong>传播时延</strong></li>
<li><strong>处理时延</strong></li>
<li><strong>排队时延</strong></li>
</ol>
<p><strong>发送时延</strong>也被成为传输时延，指的是数据帧从进入传输媒体到全部发送完毕需要的时间，等于数据帧长度/发送速率</p>
<p><strong>传播时延</strong>指的是电磁波在信道中传播所需要的时间，与信号的传播速率而不是发送速率相关</p>
<p><strong>处理时延</strong>指的是主机或者路由器处理分组（例如差错校验）花的时间</p>
<p><strong>排队时延</strong>指的是分组在路由器输入输出队列中排队等待处理所经历的时延，往往取决于网络中当时的通信量</p>
<img src="/2021/03/07/ComputerNetwork1/1.png" class>
<p>对于高速网络，提高的是数据的发送速率，而非传播速率</p>
<h3 id="往返时延"><a href="#往返时延" class="headerlink" title="往返时延"></a>往返时延</h3><p>发送端开始发送数据，到接收到另一端的确认信号</p>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>信道多少比例时间有信号通过的</p>
<h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><img src="/2021/03/07/ComputerNetwork1/2.png" class>
<p>服务数据单元，SDU</p>
<p>协议控制信息，PCI</p>
<p>协议数据单元，PDU。对等层次之间传递的数据单元，物理层成为比特，链路层成为帧，网络层成为分组，传输层成为报文等</p>
<p>n-SDU+n-PCI=n-PDU=（n-1）-SDU</p>
<p>上一层只能调用临近层的接口使用下一层的服务，下一层对上一层透明</p>
<p>如果对等层在逻辑上有直接信道，就可以不经过下层直接传递</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>对等层次之间的规则</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>同一节点相邻层级之间交换信息的连接点。SAP服务访问点</p>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>下层为紧邻的上层提供功能调用，这个过程中必须进行交换一些命令，成为服务原语</p>
<ul>
<li>请求，服务用户》服务提供者</li>
<li>指示，服务提供者》服务用户</li>
<li>相应，服务用户》服务提供者，对指示的响应</li>
<li>证实，服务提供者》服务用户，对获得请求的证实</li>
</ul>
<h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><p>面向连接/无连接：前者传输时需要先建立连接，分配缓冲区，传输后需要释放；后者需要发送时直接发送，这是不可靠的</p>
<p>可靠/不可靠：后者的正确性与可靠性需要用户保障</p>
<p>有应答/无应答：接受方收到数据是否要应答，这个应答需要传输系统内部自动实现。www服务中客户端收到页面无需应答</p>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="按照分布"><a href="#按照分布" class="headerlink" title="按照分布"></a>按照分布</h3><p>广域网（WAN）</p>
<p>城域网（MAN）</p>
<p>局域网（LAN），传统上，局域网采用广播技术，而广域网采用交换技术</p>
<p>个人区域网（PAN）</p>
<h3 id="按照传输技术"><a href="#按照传输技术" class="headerlink" title="按照传输技术"></a>按照传输技术</h3><p>广播式网络，所有计算机共享一个公共信道。局域网大多采用的方式</p>
<p>点对点网络，每条物理线路连接一对计算机</p>
<p>是否采用分组存储转发与路由选择是二者的重要区别</p>
<h3 id="按照拓扑"><a href="#按照拓扑" class="headerlink" title="按照拓扑"></a>按照拓扑</h3><p>总线/星/环 形等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/03/HTTP%E4%B8%8EWeb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/03/HTTP%E4%B8%8EWeb/" itemprop="url">HTTP与Web</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-03T16:40:36+08:00">
                2021-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.3k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>Uniform Resource Identifier，某个协议方案（http，ftp……）表示的资源的定位标识符</p>
<p>相对URI，指从浏览器中基本URI处指定的URL，如/image/1.png</p>
<p>绝对URI则由很多部分组成</p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/1.png" class>
<p>服务器地址可以选用DNS可以解析的名称，或ipv4，或方括号括起的ipv6</p>
<p>RFC：一些用来制定HTTP协议技术标准的文档。通常应用于程序需要按照这个标准，否则可能无法被访问</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP有许多版本，目前最常用的HTTP 1.1</p>
<p>HTTP默认端口号为80，但是你也可以改为8080或者其他端口</p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/2.png" class>
<p>CGI(Common Gateway Interface) 是 HTTP 服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。</p>
<p>绝大多数的 CGI 程序被用来解释处理来自表单的输入信息，并在服务器产生相应的处理，或将相应的信息反馈给浏览器。CGI 程序使网页具有交互功能。</p>
<p>浏览器显示的内容都有 HTML、XML、GIF、Flash 等，浏览器是通过 MIME Type 区分它们，决定用什么内容什么形式来显示。MIME Type 是该资源的媒体类型，MIME Type 不是个人指定的，是经过互联网（IETF）组织协商，以 RFC 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范</p>
<p>HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p>
<p>一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。</p>
<p>一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。</p>
<p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p>
<p>一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。</p>
<p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成</p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/3.png" class>
<p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/4.png" class>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\5.png" alt="image-20210311174437517"></p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/5.png" class>
<p>HTTP 响应头信息</p>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\6.png" alt="image-20210311180050115"></p>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\7.png" alt="image-20210311180116266"></p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/6.png" class>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/7.png" class>
<p>HTTP状态码</p>
<p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。HTTP状态码的英文为HTTP Status Code。下面是常见的HTTP状态码：</p>
<p>200 - 请求成功<br>301 - 资源（网页等）被永久转移到其它URL<br>404 - 请求的资源（网页等）不存在<br>500 - 内部服务器错误</p>
<p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">https://www.runoob.com/http/http-status-codes.html</a></p>
<p>HTTP content-type</p>
<p>Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。</p>
<p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;something</span><br></pre></td></tr></table></figure>
<p>常见的媒体格式类型如下：</p>
<p>text/html ： HTML格式<br>text/plain ：纯文本格式<br>text/xml ： XML格式<br>image/gif ：gif图片格式<br>image/jpeg ：jpg图片格式<br>image/png：png图片格式</p>
<p>以application开头的媒体格式类型：</p>
<p>application/xhtml+xml ：XHTML格式<br>application/xml： XML数据格式<br>application/atom+xml ：Atom XML聚合格式<br>application/json： JSON数据格式<br>application/pdf：pdf格式<br>application/msword ： Word文档格式<br>application/octet-stream ： 二进制流数据（如常见的文件下载）<br>application/x-www-form-urlencoded ： <form enctype>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）<br>另外一种常见的媒体格式是上传文件之时使用的：</form></p>
<p>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</p>
<p><a href="https://www.runoob.com/http/http-content-type.html" target="_blank" rel="noopener">https://www.runoob.com/http/http-content-type.html</a></p>
<h2 id="HTTPS与HTTP"><a href="#HTTPS与HTTP" class="headerlink" title="HTTPS与HTTP"></a>HTTPS与HTTP</h2><p><a href="https://www.jianshu.com/p/29e0ba31fb8d?tt_from=weixin（写的非常好）" target="_blank" rel="noopener">https://www.jianshu.com/p/29e0ba31fb8d?tt_from=weixin（写的非常好）</a></p>
<p>HTTP协议传输的数据都是未加密的，也就是明文，因此使用HTTP协议传输隐私信息非常不安全。</p>
<p>在计算机网络上，HTTPS（HTTP Secure）经由超文本传输协议（HTTP）进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。HTTP使用80端口通讯，而HTTPS占用443端口通讯。</p>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\9.png" alt="image-20210312081653831"></p>
<p>HTTP先与SSL先通信，之后由SSL与TCP通信</p>
<p>TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。</p>
<p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。</p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/9.png" class>
<p>密码学算法主要分为两种：对称加密和非对称加密。对称加密就是使用了一样的密钥来加密，需要在只有通信的双方知道密钥的情况下才安全。在非对称加密算法中，有公钥和私钥两种密钥，其中，公钥是公开的，不需要保密，私钥由个人持有，必须妥善保管和注意保密。加密和解密使用两种不同的密钥，用公钥加密，只有私钥能解密，用私钥加密，只有公钥能加密。RSA就是一种常见的、应用很广的非对称加密算法。</p>
<p>加密解密过程就是A往B发送消息，A用B的公钥把消息加密，只有B的私钥能解密。然后A把加密后的消息发送给B，B用自己的私钥解密就能看到了，途中没有别人可以破解消息，因为别人只有B的公钥。然后B用自己的私钥加密消息，回复给A，A用B的公钥解密读取回复。</p>
<p>在信息传输的过程中,我们通常需要验证信息的发送方的身份,这时我们转化一下思路就可以完成,把发送端的公钥发送给接收端,发送端通过把自己的内容使用私钥加密然后发送给接收端,接收端只能用发送端的公钥解密,自然就验证了发送端的身份。</p>
<p>但是这样真的安全吗？如果传输过程中消息被人修改了怎么办？如果A加密使用的公钥不一定是B的公钥呢，只是他以为是B的公钥。</p>
<p>上面的问题可以用数字签名和数字证书解决。数字签名可以解决消息被人修改的问题，数字签名是一个hash算法，A把要发送的消息通过hash算法计算出一个hash值，当做摘要，和消息一起传送，B把消息hash之后得到另一个摘要，验证是否和A传送过来的摘要相同。如果担心消息和hash摘要都被修改，可以把hash摘要用B的公钥加密，就不怕别人改了。</p>
<p>数字证书可以解决这个公钥是不是B的公钥问题，,它其实就是基于上上面所说的私钥加密数据,公钥解密来验证其身份。数字证书是由权威的CA(Certificate Authority)机构给服务端进行颁发,CA机构通过服务端提供的相关信息生成证书,证书内容包含了持有人的相关信息,服务器的公钥,签署者签名信息(数字签名)等,最重要的是公钥在数字证书中。数字证书是如何保证公钥来自请求的服务器呢?数字证书上由持有人的相关信息,通过这点可以确定其不是一个中间人;但是证书也是可以伪造的,如何保证证书为真呢? 一个证书中含有三个部分:”证书内容,散列算法,加密密文”,证书内容会被散列算法hash计算出hash值,然后使用CA机构提供的私钥进行RSA加密。当客户端发起请求时，服务器将该数字证书发送给客户端，客户端通过CA机构提供的公钥对加密密文进行解密获得散列值（数字签名），同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题。</p>
<p>目前多数浏览器会在内部植入常用认证机关的公开密钥。</p>
<p>如果个人网站只为加密传输也可以自己制作SSL证书，自己制作的证书不会受到浏览器的信任，在访问的时候由于证书验证失败而给出警告</p>
<p>证书以证书链的形式组织，在颁发证书的时候首先要有根CA机构颁发的根证书，再由根CA机构颁发一个中级CA机构的证书，最后由中级CA机构颁发具体的SSL证书。把根证书，中级证书，以及最后申请的SSL证书连在一起就形成了证书链，也称为证书路径。在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信。</p>
<p>根证书是最关键的一个证书，如果根证书不受信任，它下面颁发的所有证书都不受信任。操作系统在安装过程中会默认安装一些受信任的CA机构的根证书，可以在”运行”里面运行”certmgr.msc”启动证书管理器</p>
<p>EVSSL证书是基于国际标准的认证指导方针颁发的证书</p>
<p>HTTPS是使用非对称加密+对称加密来完成。客户端使用公钥对对称加密的密钥进行加密，然后传递给服务端，服务端使用私钥进行解密确认密钥，开始传输数据</p>
<h3 id="SSL证书的安全问题"><a href="#SSL证书的安全问题" class="headerlink" title="SSL证书的安全问题"></a>SSL证书的安全问题</h3><p>对HTTPS最常见的攻击手段就是SSL证书欺骗或者叫SSL劫持，是一种典型的中间人攻击，中间人假扮服务器与客户端通信。但是对于客户端浏览器来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误，由用户选择继续操作还是返回。</p>
<p><a href="https://blog.csdn.net/hj7jay/article/details/80221060" target="_blank" rel="noopener">https://blog.csdn.net/hj7jay/article/details/80221060</a></p>
<h3 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h3><p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息</p>
<p>握手过程的具体描述如下：</p>
<p>1）浏览器将自己支持的一套加密规则发送给网站。<br>2）网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。<br>3）浏览器获得网站证书之后浏览器要做以下工作：  a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。  b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。  c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。<br> 4）网站接收浏览器发来的数据之后要做以下的操作：  a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。  b) 使用密码加密一段握手消息，发送给浏览器。<br> 5）浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 </p>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\8.png" alt="image-20210311181101361"></p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/8.png" class>
<h2 id="确认访问用户身份的认证"><a href="#确认访问用户身份的认证" class="headerlink" title="确认访问用户身份的认证"></a>确认访问用户身份的认证</h2><p>HTTP/1.1使用的认证：</p>
<h4 id="BASIC认证，基本认证"><a href="#BASIC认证，基本认证" class="headerlink" title="BASIC认证，基本认证"></a>BASIC认证，基本认证</h4><p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\10.png" alt="image-20210312114834201"></p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/10.png" class>
<p>BASIC认证并不是加密处理；而且想要再进行一次认证时无法实现认证注销</p>
<h4 id="DIGEST认证，摘要认证"><a href="#DIGEST认证，摘要认证" class="headerlink" title="DIGEST认证，摘要认证"></a>DIGEST认证，摘要认证</h4><p><a href="https://www.cnblogs.com/xiaoxiaotank/p/11078571.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxiaotank/p/11078571.html</a></p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/12.png" class>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\12.png" alt="image-20210312120953961"></p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/WWW-Authenticate" target="_blank" rel="noopener"><code>WWW-Authentication</code></a>：用来定义使用何种方式（Basic、Digest、Bearer等）去进行认证以获取受保护的资源</li>
<li><code>realm</code>：表示Web服务器中受保护文档的安全域（比如公司财务信息域和公司员工信息域），用来指示需要哪个域的用户名和密码</li>
<li><code>qop</code>：保护质量，包含<code>auth</code>（默认的）和<code>auth-int</code>（增加了报文完整性检测）两种策略，（可以为空，但是）不推荐为空值</li>
<li><code>nonce</code>：服务端向客户端发送质询时附带的一个随机数，这个数会经常发生变化。客户端计算密码摘要时将其附加上去，使得多次生成同一用户的密码摘要各不相同，用来防止重放攻击</li>
<li><code>nc</code>：nonce计数器，是一个16进制的数值，表示同一nonce下客户端发送出请求的数量。例如，在响应的第一个请求中，客户端将发送“nc=00000001”。这个指示值的目的是让服务器保持这个计数器的一个副本，以便检测重复的请求</li>
<li><code>cnonce</code>：客户端随机数，这是一个不透明的字符串值，由客户端提供，并且客户端和服务器都会使用，以避免用明文文本。这使得双方都可以查验对方的身份，并对消息的完整性提供一些保护</li>
<li><code>response</code>：这是由用户代理软件计算出的一个字符串，以证明用户知道口令</li>
<li><code>Authorization-Info</code>：用于返回一些与授权会话相关的附加信息</li>
<li><code>nextnonce</code>：下一个服务端随机数，使客户端可以预先发送正确的摘要</li>
<li><code>rspauth</code>：响应摘要，用于客户端对服务端进行认证</li>
<li><code>stale</code>：当密码摘要使用的随机数过期时，服务器可以返回一个附带有新随机数的401响应，并指定<code>stale=true</code>，表示服务器在告知客户端用新的随机数来重试，而不再要求用户重新输入用户名和密码了</li>
</ul>
<h4 id="SSL客户端认证"><a href="#SSL客户端认证" class="headerlink" title="SSL客户端认证"></a>SSL客户端认证</h4><img src="/2021/03/03/HTTP%E4%B8%8EWeb/11.png" class>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\11.png" alt="image-20210312115459032"></p>
<h4 id="FormBase认证，基于表单认证"><a href="#FormBase认证，基于表单认证" class="headerlink" title="FormBase认证，基于表单认证"></a>FormBase认证，基于表单认证</h4><p>客户端向服务器上web发送登录信息，之后登录</p>
<h4 id="session管理与cookie"><a href="#session管理与cookie" class="headerlink" title="session管理与cookie"></a>session管理与cookie</h4><p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\13.png" alt="image-20210312121800701"></p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/13.png" class>
<p>如果session id被盗，就可以伪装成为用户进行恶意操作</p>
<h2 id="拓展协议"><a href="#拓展协议" class="headerlink" title="拓展协议"></a>拓展协议</h2><p>Ajax，每次只更新部分页面，加快传输速度</p>
<p>Comet，服务端有内容更新后，直接向客户端返回响应而不是请求等待</p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/14.png" class>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\14.png" alt="image-20210312122312898"></p>
<p>SPDY：</p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/15.png" class>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\15.png" alt="image-20210312122416337"></p>
<p>这样可以实现多路复用（单个域名通信下），优先级分配，HTTP首部压缩等加速功能</p>
<p>websocket：</p>
<p>websocket即web浏览器与web服务器间全双工标准，可以持续保持连接状态，支持服务器向客户端进行推送而不必等待请求</p>
<p>为实现通信，需要再HTTP连接后进行一次握手，用到HTTP首部的Upgrade字段</p>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\16.png" alt="image-20210312122747372"></p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/16.png" class>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\17.png" alt="image-20210312122931298"></p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/17.png" class>
<p><img src="/03/03/HTTP%E4%B8%8EWeb/blog\blog\source\_posts\HTTP与Web\18.png" alt="image-20210312122958953"></p>
<img src="/2021/03/03/HTTP%E4%B8%8EWeb/18.png" class>
<p>连接建立后，不再使用HTTP数据帧而是websocket独立的数据帧</p>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/01/the-limitations-of-deep-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/01/the-limitations-of-deep-learning/" itemprop="url">limitations and future of deep learning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-01T11:21:46+08:00">
                2021-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="limitations"><a href="#limitations" class="headerlink" title="limitations"></a>limitations</h1><p><a href="https://blog.keras.io/the-limitations-of-deep-learning.html" target="_blank" rel="noopener">https://blog.keras.io/the-limitations-of-deep-learning.html</a></p>
<h2 id="Deep-learning-the-geometric-view"><a href="#Deep-learning-the-geometric-view" class="headerlink" title="Deep learning: the geometric view"></a>Deep learning: the geometric view</h2><p>In deep learning, everything is a vector, i.e. everything is a <em>point</em> in a <em>geometric space</em>. </p>
<p>Together, the chain of layers of the model forms one very complex geometric transformation</p>
<p>This complex transformation attempts to maps the input space to the target space</p>
<p>A key characteristic of this geometric transformation is that it must be <em>differentiable</em>, which is required in order for us to be able to learn its parameters via gradient descent</p>
<p>总而言之，这就是将高维数据的复杂流形解压的过程，就像把一个揉皱的纸球解开弄平一样</p>
<h2 id="The-limitations-of-deep-learning"><a href="#The-limitations-of-deep-learning" class="headerlink" title="The limitations of deep learning"></a>The limitations of deep learning</h2><p>The space of applications that can be implemented with this simple strategy is nearly infinite</p>
<p> In general, anything that requires reasoning—like programming, or applying the scientific method—long-term planning, and algorithmic-like data manipulation, is out of reach for deep learning models— Even learning a sorting algorithm with a deep neural network is tremendously difficult.</p>
<p>This is because a deep learning model is “just” <em>a chain of simple, continuous geometric transformations</em> mapping one vector space into another</p>
<p>most programs cannot be expressed as deep learning models</p>
<p>most of the programs that one may wish to learn cannot be expressed as a continuous geometric morphing of a data manifold</p>
<h2 id="The-risk-of-anthropomorphizing-machine-learning-models"><a href="#The-risk-of-anthropomorphizing-machine-learning-models" class="headerlink" title="The risk of anthropomorphizing machine learning models"></a>The risk of anthropomorphizing machine learning models</h2><p>One very real risk with contemporary AI is that of misinterpreting what deep learning models do, and overestimating their abilities</p>
<p> A fundamental feature of the human mind is our “theory of mind”, our tendency to project intentions, beliefs and knowledge on the things around us</p>
<p>In particular, this is highlighted by “adversarial examples”, which are input samples to a deep learning network that are designed to trick the model into misclassifying them</p>
<p>By taking a picture of a panda and adding to it a “gibbon” gradient, we can get a neural network to classify this panda as a gibbon</p>
<p>In short, deep learning models do not have any understanding of their input, at least not in any human sense</p>
<p>never fall into the trap of believing that neural networks understand the task they perform they don’t, at least not in a way that would make sense to us</p>

<h2 id="Local-generalization-versus-extreme-generalization"><a href="#Local-generalization-versus-extreme-generalization" class="headerlink" title="Local generalization versus extreme generalization"></a>Local generalization versus extreme generalization</h2><p>This ability to handle hypotheticals, to expand our mental model space far beyond what we can experience directly, in a word, to perform <em>abstraction</em> and <em>reasoning</em>, is arguably the defining characteristic of human cognition— I call it “extreme generalization”: an ability to adapt to novel, never experienced before situations, using very little data or even no new data at all.</p>
<p>This stands in sharp contrast with what deep nets do, which I would call “local generalization”: the mapping from inputs to outputs performed by deep nets quickly stops making sense if new inputs differ even slightly from what they saw at training time. </p>
<p>人类有抽象建模能力，但是深度网络不行。如果想要训练在某个城市里自动驾驶的深度网络，可能需要出成千上百次错误，而换一个城市，这个网络就可能出现问题——但是人类不会</p>

<h2 id="Take-aways"><a href="#Take-aways" class="headerlink" title="Take-aways"></a>Take-aways</h2><p>To lift some of these limitations and start competing with human brains, we need to move away from straightforward input-to-output mappings, and on to <em>reasoning</em> and <em>abstraction</em>. </p>
<h1 id="future"><a href="#future" class="headerlink" title="future"></a>future</h1><p><a href="https://blog.keras.io/the-future-of-deep-learning.html" target="_blank" rel="noopener">https://blog.keras.io/the-future-of-deep-learning.html</a></p>
<h2 id="main-directions"><a href="#main-directions" class="headerlink" title="main directions"></a>main directions</h2><ul>
<li>Models closer to general-purpose computer programs, built on top of far richer primitives than our current differentiable layers—this is how we will get to <em>reasoning</em> and <em>abstraction</em>, the fundamental weakness of current models</li>
<li>New forms of learning that make the above possible—allowing models to move away from just differentiable transforms.</li>
<li>Models that require less involvement from human engineers—it shouldn’t be your job to tune knobs endlessly.</li>
<li>Greater, systematic reuse of previously learned features and architectures; meta-learning systems based on reusable and modular program subroutines.</li>
</ul>
<h2 id="Models-as-programs"><a href="#Models-as-programs" class="headerlink" title="Models as programs"></a>Models as programs</h2><p>a move away from models that perform purely <em>pattern recognition</em> and can only achieve <em>local generalization</em>, towards models capable of <em>abstraction</em> and <em>reasoning</em>, that can achieve <em>extreme generalization</em></p>
<p> In DeepMind’s AlphaGo, for example, most of the “intelligence” on display is designed and hard-coded by expert programmers (e.g. Monte-Carlo tree search); learning from data only happens in specialized submodules (value networks and policy networks). But in the future, such AI systems may well be fully learned, with no human involvement</p>
<p>例如RNN，不是简单的只用一个for，而是使用大量的编程原语，模型可以自由操作，以扩展其处理功能，如if分支、while语句、变量创建、长期内存磁盘存储、排序操作符、高级数据结构(如列表、图和哈希表)等等</p>
<p>  A big way is <em>program synthesis</em>， The difference is that instead of learning parameter values in a hard-coded program (a neural network), we generate <em>source code</em> via a discrete search process.</p>
<p>深度学习和program synthesis之间可能出现一个交叉子域，不会直接生成通用的编程语言编写的程序，而是生成神经网络，并通过for等编程原语来增强</p>
<h2 id="Beyond-backpropagation-and-differentiable-layers"><a href="#Beyond-backpropagation-and-differentiable-layers" class="headerlink" title="Beyond backpropagation and differentiable layers"></a>Beyond backpropagation and differentiable layers</h2><p>If machine learning models become more like programs, then they will mostly no longer be differentiable</p>
<p>We need to figure out to train non-differentiable systems efficiently. Current approaches include genetic algorithms, “evolution strategies”, certain reinforcement learning methods, and ADMM (alternating direction method of multipliers)</p>
<h2 id="Automated-machine-learning"><a href="#Automated-machine-learning" class="headerlink" title="Automated machine learning"></a>Automated machine learning</h2><p> Learning architectures automatically goes hand in hand with the use of richer sets of primitives and program-like machine learning models.</p>
<p>Unfortunately, the data munging part is tough to automate, since it often requires domain knowledge as well as a clear high-level understanding of what the engineer wants to achieve.</p>
<p>At the most basic level, such a system would simply tune the number of layers in a stack, their order, and the number of units or filters in each layer. </p>
<p>Another important AutoML direction is to learn model architecture jointly with model weights</p>
<h2 id="Lifelong-learning-and-modular-subroutine-reuse"><a href="#Lifelong-learning-and-modular-subroutine-reuse" class="headerlink" title="Lifelong learning and modular subroutine reuse"></a>Lifelong learning and modular subroutine reuse</h2><p>If models get more complex and are built on top of richer algorithmic primitives, then this increased complexity will require higher reuse between tasks</p>
<p>Much like you don’t learn English from scratch every time you open a new book—that would be impossible. </p>
<p>我们不仅会利用以前学习的功能（子模型权重），还会利用模型架构和训练过程。 随着模型变得更像程序，我们将开始重用程序子程序，例如人类编程语言中的函数和类</p>
<p>想想当今的软件开发过程：工程师解决了特定问题（例如，Python中的HTTP查询）后，他们会将其打包为一个抽象且可重用的库。 将来面临类似问题的工程师可以简单地搜索现有的库，下载一个库并在自己的项目中使用它。 以类似的方式，将来，元学习系统将能够通过在高级可重用块的全局库中进行筛选来组装新程序。 当系统发现自己正在为几种不同的任务开发类似的程序子例程时，就会提出一个“抽象的”、可重用的子程序版本，并将其存储在全局库中。 这样的过程将实现抽象的能力，这是实现“极端泛化”的必要组件：可以说跨不同任务和领域有用的子例程可以“抽象”问题解决的某些方面。 “抽象”的定义类似于软件工程中的抽象概念。 这些子例程可以是geometric （具有预训练表示形式的深度学习模块），也可以是algorithmic （更接近于当代软件工程师操作的库）</p>
<h2 id="Deep-learning-in-artificial-intelligence-solid-development-amp-tricks"><a href="#Deep-learning-in-artificial-intelligence-solid-development-amp-tricks" class="headerlink" title="Deep learning in artificial intelligence: solid development &amp; tricks"></a>Deep learning in artificial intelligence: solid development &amp; tricks</h2><p>How does a deep network work?</p>
<p>• Intuitive design or theoretical foundation?</p>
<p>• Change network structure but why is a structure better than another?</p>
<p>• Adjust hyper-parameters but why are these hyper-parameters better than those?</p>
<p>• Making a prediction but what is the rationale of the prediction</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/29/namingJava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/29/namingJava/" itemprop="url">Android项目命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-29T18:05:42+08:00">
                2021-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  183
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面向贡献者的 AOSP 代码样式指南：<a href="https://source.android.com/source/code-style#follow-field-naming-conventions" target="_blank" rel="noopener">https://source.android.com/source/code-style#follow-field-naming-conventions</a><br>Android：你不能忽略的代码命名规范：<a href="https://www.jianshu.com/p/b7a644ea0d25" target="_blank" rel="noopener">https://www.jianshu.com/p/b7a644ea0d25</a></p>

<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><img src="/2021/01/29/namingJava/3.png" class>
<h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>小骆驼拼写法（除首字母外各个单词首字母全部大写）</p>
<p>非静态非public成员以m开头<br>静态全部大写，下划线分割</p>
<p>临时变量全部小写</p>
<h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><img src="/2021/01/29/namingJava/4.png" class>
<p>参数小骆驼法</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><img src="/2021/01/29/namingJava/5.webp" class>
<p>按照小写+下划线隔开的规则</p>
<p>可以参考下面的命名方式（有些繁琐，且缩写不便记忆）</p>
<img src="/2021/01/29/namingJava/6.webp" class><img src="/2021/01/29/namingJava/7.webp" class><img src="/2021/01/29/namingJava/8.webp" class><img src="/2021/01/29/namingJava/9.webp" class><img src="/2021/01/29/namingJava/10.webp" class><img src="/2021/01/29/namingJava/11.webp" class>
<h1 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h1><p>大骆驼</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>每个类/函数加上注释<br>左大括号不单独占一行，与其前面的代码位于同一行</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/28/MVVMSample/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/28/MVVMSample/" itemprop="url">MVVMSample</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-28T13:50:27+08:00">
                2021-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/KunMinX/Jetpack-MVVM-Best-Practice" target="_blank" rel="noopener">https://github.com/KunMinX/Jetpack-MVVM-Best-Practice</a></p>
<h2 id="strict-databinding-3-6-2-beta1-sources"><a href="#strict-databinding-3-6-2-beta1-sources" class="headerlink" title="strict-databinding-3.6.2-beta1-sources"></a>strict-databinding-3.6.2-beta1-sources</h2><h3 id="DataBindingActivity-java"><a href="#DataBindingActivity-java" class="headerlink" title="DataBindingActivity.java"></a>DataBindingActivity.java</h3><h4 id="数据绑定库"><a href="#数据绑定库" class="headerlink" title="数据绑定库"></a>数据绑定库</h4><p>文档太晦涩<a href="https://juejin.cn/post/6844903784284422152" target="_blank" rel="noopener">https://juejin.cn/post/6844903784284422152</a></p>
<p><a href="https://developer.android.com/topic/libraries/data-binding/start" target="_blank" rel="noopener">https://developer.android.com/topic/libraries/data-binding/start</a></p>
<p>数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。借助布局文件中的绑定组件，您可以移除 Activity 中的许多界面框架调用，使其维护起来更简单、方便。可以采用表达式语言进行更复杂的绑定。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.userName&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>要将应用配置为使用数据绑定，请在应用模块的 <code>build.gradle</code> 文件中添加 <code>dataBinding</code> 元素</p>
<p>数据绑定布局文件略有不同，以根标记 <code>layout</code> 开头，后跟 <code>data</code> 元素和 <code>view</code> 根元素</p>
<p>系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写形式并在末尾添加 Binding 后缀；建议的绑定创建方法是在扩充布局时创建</p>
<p>如果您要在 <code>Fragment</code>、<code>ListView</code> 或 <code>RecyclerView</code> 适配器中使用数据绑定项，您可能更愿意使用绑定类或<code>DataBindingUtil</code>类的 <code>inflate()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>inflate()</code>有多个绑定版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    MyLayoutBinding binding = MyLayoutBinding.inflate(getLayoutInflater());</span><br><span class="line"></span><br><span class="line">    setContentView(binding.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);</span><br></pre></td></tr></table></figure>
<p>通过数据绑定，您可以编写从视图分派的表达式处理事件。可以采用两种机制：</p>
<p>方法引用:事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定 <a href="https://developer.android.com/reference/android/view/View#attr_android:onClick" target="_blank" rel="noopener"><code>android:onClick</code></a> 的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickFriend</span><span class="params">(View view)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"handlers"</span> <span class="attr">type</span>=<span class="string">"com.example.MyHandlers"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:onClick</span>=<span class="string">"@&#123;handlers::onClickFriend&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>监听器绑定:监听器绑定是在事件发生时运行的绑定表达式。它们类似于方法引用，但允许您运行任意数据绑定表达式。在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveClick</span><span class="params">(Task task)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"task"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Task"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"presenter"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Presenter"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span> <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">"@&#123;() -&gt; presenter.onSaveClick(task)&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>您可以忽略方法的所有参数，也可以命名所有参数。如果您想命名参数，则可以在表达式中使用这些参数</p>
<p>可以在布局文件中导入类，定义变量等</p>
<p>可观察性是指一个对象将其数据变化告知其他对象的能力。通过数据绑定库，您可以让对象、字段或集合变为可观察。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; firstName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; lastName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableInt age = <span class="keyword">new</span> ObservableInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要访问字段，需要使用set（）与get（）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.firstName.set(<span class="string">"Google"</span>);</span><br><span class="line"><span class="keyword">int</span> age = user.age.get();</span><br></pre></td></tr></table></figure>
<p>所有生成的绑定类都是从 <a href="https://developer.android.com/reference/androidx/databinding/ViewDataBinding" target="_blank" rel="noopener"><code>ViewDataBinding</code></a> 类继承而来的</p>
<p>标准可观察字段有许多，例如ObservableArrayMap，ObservableArrayList等</p>
<p>实现 <a href="https://developer.android.com/reference/android/databinding/Observable" target="_blank" rel="noopener"><code>Observable</code></a> 接口的类允许注册监听器，以便它们接收有关可观察对象的属性更改的通知。为便于开发，数据绑定库提供了用于实现监听器注册机制的 <a href="https://developer.android.com/reference/android/databinding/BaseObservable" target="_blank" rel="noopener"><code>BaseObservable</code></a> 类。实现 <code>BaseObservable</code> 的数据类负责在属性更改时发出通知。具体操作过程是向 getter 分配 <a href="https://developer.android.com/reference/android/databinding/Bindable" target="_blank" rel="noopener"><code>Bindable</code></a> 注释，然后在 setter 中调用 <a href="https://developer.android.com/reference/android/databinding/BaseObservable#notifypropertychanged" target="_blank" rel="noopener"><code>notifyPropertyChanged()</code></a> 方法。数据绑定在模块包中生成一个名为 <code>BR</code> 的类，该类包含用于数据绑定的资源的 ID。在编译期间，<a href="https://developer.android.com/reference/android/databinding/Bindable" target="_blank" rel="noopener"><code>Bindable</code></a> 注释会在 <code>BR</code> 类文件中生成一个条目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        notifyPropertyChanged(BR.firstName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        notifyPropertyChanged(BR.lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绑定适配器负责发出相应的框架调用来设置值。只要绑定值发生更改，生成的绑定类就必须使用绑定表达式在视图上调用 setter 方法。您可以允许数据绑定库自动确定方法、显式声明方法或提供选择方法的自定义逻辑。</p>
<p>设置特征值</p>
<ul>
<li><p>自动选择</p>
</li>
<li><p>指定自定义方法：使用使用 <a href="https://developer.android.com/reference/androidx/databinding/BindingMethods" target="_blank" rel="noopener"><code>BindingMethods</code></a> 注释与 setter 相关联。注释与类一起使用，可以包含多个 <a href="https://developer.android.com/reference/androidx/databinding/BindingMethod" target="_blank" rel="noopener"><code>BindingMethod</code></a> 注释，每个注释对应一个重命名的方法</p>
</li>
<li><p>```java</p>
<pre><code>@BindingMethods({
       @BindingMethod(type = &quot;android.widget.ImageView&quot;,
                      attribute = &quot;android:tint&quot;,
                      method = &quot;setImageTintList&quot;),
})
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 提供自定义逻辑：例如，&#96;android:paddingLeft&#96; 特性没有关联的 setter，而是提供了 &#96;setPadding(left, top, right, bottom)&#96; 方法。使用 [&#96;BindingAdapter&#96;](https:&#x2F;&#x2F;developer.android.com&#x2F;reference&#x2F;androidx&#x2F;databinding&#x2F;BindingAdapter) 注释的静态绑定适配器方法支持自定义特性 setter 的调用方式。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">    @BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="line">    public static void setPaddingLeft(View view, int padding) &#123;</span><br><span class="line">      view.setPadding(padding,</span><br><span class="line">                      view.getPaddingTop(),</span><br><span class="line">                      view.getPaddingRight(),</span><br><span class="line">                      view.getPaddingBottom());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参数类型非常重要。第一个参数用于确定与特性关联的视图类型，第二个参数用于确定在给定特性的绑定表达式中接受的类型</p>
<h4 id="将架构组件整合到应用"><a href="#将架构组件整合到应用" class="headerlink" title="将架构组件整合到应用"></a>将架构组件整合到应用</h4><p>将LiveData作为数据绑定来源：您需要指定生命周期所有者来定义 <code>LiveData</code> 对象的范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line">        UserBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Specify the current activity as the lifecycle owner.</span></span><br><span class="line">        binding.setLifecycleOwner(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ViewModel管理相关数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Obtain the ViewModel component.</span></span><br><span class="line">        UserModel userModel = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>).get(UserModel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line">        UserBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assign the component to a property in the binding class.</span></span><br><span class="line">        binding.viewmodel = userModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:checked</span>=<span class="string">"@&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;() -&gt; viewmodel.rememberMeChanged()&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用observable ViewModel从 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 类继承而来并实现 <a href="https://developer.android.com/reference/androidx/databinding/Observable" target="_blank" rel="noopener"><code>Observable</code></a> 接口的类。可以使用 <a href="https://developer.android.com/reference/androidx/databinding/Observable#addOnPropertyChangedCallback(android.databinding.Observable.OnPropertyChangedCallback" target="_blank" rel="noopener"><code>addOnPropertyChangedCallback()</code></a>) 和 <a href="https://developer.android.com/reference/androidx/databinding/Observable#removeOnPropertyChangedCallback(android.databinding.Observable.OnPropertyChangedCallback" target="_blank" rel="noopener"><code>removeOnPropertyChangedCallback()</code></a>) 方法提供观察器订阅或取消订阅通知时的自定义逻辑。还可以在 <a href="https://developer.android.com/reference/androidx/databinding/BaseObservable#notifyPropertyChanged(int" target="_blank" rel="noopener"><code>notifyPropertyChanged()</code></a>) 方法中提供属性更改时运行的自定义逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A ViewModel that is also an Observable,</span></span><br><span class="line"><span class="comment"> * to be used with the Data Binding Library.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObservableViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> <span class="keyword">implements</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PropertyChangeRegistry callbacks = <span class="keyword">new</span> PropertyChangeRegistry();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addOnPropertyChangedCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Observable.OnPropertyChangedCallback callback)</span> </span>&#123;</span><br><span class="line">        callbacks.add(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeOnPropertyChangedCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Observable.OnPropertyChangedCallback callback)</span> </span>&#123;</span><br><span class="line">        callbacks.remove(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies observers that all properties of this instance have changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies observers that a specific property has changed. The getter for the</span></span><br><span class="line"><span class="comment">     * property that changes should be marked with the <span class="doctag">@Bindable</span> annotation to</span></span><br><span class="line"><span class="comment">     * generate a field in the BR class to be used as the fieldId parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldId The generated BR id for the Bindable field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyPropertyChanged</span><span class="params">(<span class="keyword">int</span> fieldId)</span> </span>&#123;</span><br><span class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, fieldId, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h4><p>使用getDataBindingConfig得到config并进行绑定，绑定至mBinding</p>
<h4 id="getBinding"><a href="#getBinding" class="headerlink" title="getBinding"></a>getBinding</h4><p>返回ViewDataBinding</p>
<h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><h4 id="lt-receiver-gt"><a href="#lt-receiver-gt" class="headerlink" title="&lt; /receiver&gt;"></a>&lt; /receiver&gt;</h4><p>所有静态注册的广播接收器都是在这里进行注册的。首先通过 android:name 来指定具体注册哪一个广播接收器，然后在标签里加入想要接收的广播就行了</p>
<p>例如Android系统启动完成后会发出一条值为 android.intent.action.BOOT_COMPLETED的广 播</p>
<h2 id="architecture"><a href="#architecture" class="headerlink" title="architecture"></a>architecture</h2><h3 id="AndroidManifest-xml-1"><a href="#AndroidManifest-xml-1" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><h4 id="lt-meta-data-gt"><a href="#lt-meta-data-gt" class="headerlink" title="&lt; meta-data &gt;"></a>&lt; meta-data &gt;</h4><p>标签可以为其父组件提供额外的，能够被外地访问的数据，它很方便的增加了相应组件的个性化数据，原则上想添加多少就多少，但是不建议添加多行</p>
<p>它采用键-值（name-value）的形式来存储数据，自定义名称</p>
<h4 id="lt-provider-gt"><a href="#lt-provider-gt" class="headerlink" title="&lt; provider&gt;"></a>&lt; provider&gt;</h4><p>注册内容提供器</p>
<h3 id="CommonViewPagerAdapter-java"><a href="#CommonViewPagerAdapter-java" class="headerlink" title="CommonViewPagerAdapter.java"></a>CommonViewPagerAdapter.java</h3><p><a href="https://www.kaelli.com/30.html" target="_blank" rel="noopener">https://www.kaelli.com/30.html</a></p>
<h4 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h4><p>ViewPager是一个布局容器，实际上是一个特别的ViewGroup。它允许用户通过左右滑动翻页的操作来实现数据展示的变化（实际上可以修改后实现竖直方向的上下翻页）。ViewPager需要设置由开发者实现的适配器PagerAdapter，以此来决定在每个位置上该展示什么样的数据</p>
<h4 id="PagerAdapter"><a href="#PagerAdapter" class="headerlink" title="PagerAdapter"></a>PagerAdapter</h4><p>抽象类，至少实现4个方法</p>
<ul>
<li>getCount：一共有多少个页面</li>
<li>isViewFromObject：page 和object是否关联</li>
<li>instantiateItem：创建给定位置的页面，适配器会把创建的View添加到给定的容器container中</li>
<li>destroyItem：移除给定位置的页面，适配器会把View从容器里删除</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/NaNillll" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
  
 
  
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">50.9k</span>
  
</div>











        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
