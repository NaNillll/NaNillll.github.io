<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta name="google-site-verification" content="kWcVT9oyylmyb6DohoXWge7VpBUZQVIptcOSS5Gr9wc" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="ComputerNetwork," />










<meta name="description" content="传输层提供了主机应用程序进程之间的端到端的服务。实现了分用与复用。进行了报文差错计算。 只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。    在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。即复用 (multiplexing)和分用 (demultiplexing)。   根据应用程序的不同需求，运输层需要有两种不同">
<meta property="og:type" content="article">
<meta property="og:title" content="运输层">
<meta property="og:url" content="http://yoursite.com/2021/03/10/ComputerNetwork5/index.html">
<meta property="og:site_name" content="The Grimoire of NaNillll">
<meta property="og:description" content="传输层提供了主机应用程序进程之间的端到端的服务。实现了分用与复用。进行了报文差错计算。 只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。    在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。即复用 (multiplexing)和分用 (demultiplexing)。   根据应用程序的不同需求，运输层需要有两种不同">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/1.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/2.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/3.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/4.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/5.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/7.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/6.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/8.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/9.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/10.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/11.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/12.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/13.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/15.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/16.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/17.png">
<meta property="og:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/18.png">
<meta property="article:published_time" content="2021-03-10T00:08:06.000Z">
<meta property="article:modified_time" content="2021-03-10T09:51:51.899Z">
<meta property="article:tag" content="ComputerNetwork">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/03/10/ComputerNetwork5/blog/blog/source/_posts/ComputerNetwork5/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/03/10/ComputerNetwork5/"/>





  <title>运输层 | The Grimoire of NaNillll</title>
  








<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">The Grimoire of NaNillll</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/10/ComputerNetwork5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Grimoire of NaNillll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">运输层</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-10T08:08:06+08:00">
                2021-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.5k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>传输层提供了主机应用程序进程之间的端到端的服务。实现了分用与复用。进行了报文差错计算。</p>
<p>只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 </p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\1.png" alt="image-20210310081042765"></p>

<p>在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。即复用 (multiplexing)和分用 (demultiplexing)。</p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\2.png" alt="image-20210310081225873"></p>

<p>根据应用程序的不同需求，运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP 。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 </p>
<h2 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h2><p>(1) 用户数据报协议 UDP (User Datagram Protocol)，提供无连接服务。在传送数据之前不需要先建立连接。传送的数据单位协议是 UDP 报文。对方的运输层在收到 UDP 报文后，不需要给出任何确认。<br>(2) 传输控制协议 TCP (Transmission Control Protocol)，提供面向连接的服务。<br>传送的数据单位协议是 TCP 报文段 (segment)。<br>TCP 不提供广播或多播服务。</p>
<p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。</p>
<h2 id="TCP-IP-运输层端口"><a href="#TCP-IP-运输层端口" class="headerlink" title="TCP/IP 运输层端口"></a>TCP/IP 运输层端口</h2><p>端口用一个 16 位端口号进行标志。端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在互联网中，不同计算机的相同端口号是没有联系的。</p>
<p>因此两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。</p>
<p>(1) 服务器端使用的端口号<br>熟知端口，数值一般为 0~1023，应用层协议在服务器端的默认端口号，客户端进程的端口号是客户端进程任意临时指定的<br>登记端口号，数值为 1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。<br>(2) 客户端使用的端口号<br>又称为短暂端口号，数值为 49152~65535，留给客户进程选择暂时使用。<br>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 </p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\3.png" alt="image-20210310081924823"></p>

<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能：复用和分用的功能；差错检测的功能</p>
<p>UDP 的主要特点 ：</p>
<ul>
<li>(1) UDP 是无连接的，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。也无连接状态。</li>
<li>(2) UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li>
<li>(3) UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。因此应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率</li>
<li>(4) UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 </li>
<li>(5) UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>(6) UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li>
</ul>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\4.png" alt="image-20210310082646269"></p>
<p>伪首部只是为了计算校验和</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 是面向连接的运输层协议。每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。<br>TCP 提供可靠交付的服务。<br>TCP 提供全双工通信。<br>面向字节流<br>TCP 中的“流”(stream)指的是流入或流出进程的字节序列。<br>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</p>
<p>TCP与网络虚电路的区别在于，TCP报文段在传输层抽象的逻辑信道中传输，路由器不可见；而虚电路经过的交换节点都必须保存虚电路的状态信息，如果使用了虚电路，就无法提供无连接服务</p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\5.png" alt="image-20210310083344105"></p>
<p>TCP 不关心应用进程一次把多长的报文发送到 TCP 缓存。TCP 对连续的字节流进行分段，形成 TCP 报文段。TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 </p>
<p>TCP 连接的端点叫做套接字 (socket) 或插口。端口号拼接到 IP 地址即构成了套接字。每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。</p>
<h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\7.png" alt="image-20210310091000730"></p>
<h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\6.png" alt="image-20210310083731050"></p>
<h4 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h4><p>B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。<br>A 为每一个已发送的分组都设置了一个超时计时器。A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。</p>
<p>若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。<br>假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：<br>第一，丢弃这个重复的分组 M1，不向上层交付。<br>第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认</p>
<p>若传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。<br>A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。<br>B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。</p>
<h3 id="自动重传请求-ARQ"><a href="#自动重传请求-ARQ" class="headerlink" title="自动重传请求 ARQ"></a>自动重传请求 ARQ</h3><p>自动重传请求 ARQ  (Automatic Repeat reQuest)。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>之前的停止等待协议属于自动重传请求ARQ</p>
<h3 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h3><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。<br>流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。</p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\8.png" alt="image-20210310091136698"></p>

<h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h3><p>发送方维持发送窗口，窗口的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。<br>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p>
<p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。优点：容易实现，即使确认丢失也不必重传。缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<p>这种协议又称为回退N（Go-back-N）</p>
<h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p>一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。<br>TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。</p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\9.png" alt="image-20210310091523302"></p>
<p>序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 </p>
<p>确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 </p>
<p>窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</p>
<h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\10.png" alt="image-20210310091818706"></p>
<p>为了选择重传时间，TCP采用了自适应算法: </p>
<p>新的RTTS  = (1-<script type="math/tex">\alpha</script>) <em> (旧的RTTS) +<script type="math/tex">\alpha</script></em> (新的RTT样本)                           </p>
<p>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就重新计算一次</p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\11.png" alt="image-20210310093156162"></p>
<p>因此使用修正的 Karn 算法 ，报文段每重传一次，就把 RTT 增大一些，一般将RTT修正为之前的两倍</p>
<h3 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h3><p>若接受方接受到的数据字节流序号不连续且缺少某些序号，如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。</p>
<p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。<br>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。</p>
<h2 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h2><p>流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 </p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\12.png" alt="image-20210310102631435"></p>
<p>这可能发生死锁：B 向 A 发送了零窗口的报文段。之后B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p>
<p>为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。若窗口不是零，则死锁的僵局就可以打破了。 </p>
<p>可以用不同的机制来控制 TCP 报文段的发送时机:</p>
<p>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。<br>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push)操作。<br>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段发送出去。</p>
<h2 id="发送与接受方的传输策略"><a href="#发送与接受方的传输策略" class="headerlink" title="发送与接受方的传输策略"></a>发送与接受方的传输策略</h2><p>若发送方 TCP 每次接收到一字节的数据后就发送，这样，发送一个字节需要形成 41 字节长的 IP 数据报。若接收方确认，就需回送一个ACK。效率很低。会造成效率较低，可使用Nagle算法</p>
<p>Nagle算法：</p>
<p>若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。<br>当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。<br>只有在收到对前一个报文段的确认后才继续发送下一个报文段。<br>当到达的数据已达到报文段的最大长度时，就立即发送。</p>
<p>这样可以降低ACK次数，同时降低重传导致的效率下降</p>
<p>若接收方的应用进程每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。效果</p>
<p>解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。</p>
<h2 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h2><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。</p>
<p>增大资源不一定解决拥塞：例如增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞。</p>
<h3 id="拥塞控制与流量控制"><a href="#拥塞控制与流量控制" class="headerlink" title="拥塞控制与流量控制"></a>拥塞控制与流量控制</h3><p>拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 </p>
<p>而流量控制往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）。所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\13.png" alt="image-20210310104619646"></p>
<h3 id="开环控制和闭环控制"><a href="#开环控制和闭环控制" class="headerlink" title="开环控制和闭环控制"></a>开环控制和闭环控制</h3><p>开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。<br>闭环控制方法是基于反馈环路的概念。属于闭环控制的有以下几种措施：<br>(1) 监测网络系统以便检测到拥塞在何时、何处发生。<br>(2) 将拥塞发生的信息传送到可采取行动的地方。<br>(3) 调整网络系统的运行以解决出现的问题。</p>
<h3 id="拥塞的指标"><a href="#拥塞的指标" class="headerlink" title="拥塞的指标"></a>拥塞的指标</h3><p>主要指标有：<br>由于缺少缓存空间而被丢弃的分组的百分数；<br>平均队列长度；<br>超时重传的分组数；<br>平均分组时延；<br>分组时延的标准差，等等。</p>
<h3 id="TCP-的拥塞控制方法"><a href="#TCP-的拥塞控制方法" class="headerlink" title="TCP 的拥塞控制方法"></a>TCP 的拥塞控制方法</h3><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。<br>TCP发送方维持一个拥塞窗口 CWND (Congestion Window)<br>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<br>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。<br>所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：min(公告窗口值，拥塞窗口值)</p>
<h3 id="判断拥塞"><a href="#判断拥塞" class="headerlink" title="判断拥塞"></a>判断拥塞</h3><p>重传定时器超时：现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于 1 %）。只要出现了超时，就可以猜想网络出现了拥塞。<br>收到三个相同（重复）的 ACK：个别报文段会在网络中丢失，预示可能会出现拥塞（实际未发生拥塞），因此可以尽快采取控制措施，避免拥塞。</p>
<h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p>慢开始 ：由小到大逐渐增大拥塞窗口数值。初始拥塞窗口 cwnd 不超过2至4个发送方的最大报文段SMSS的数值。在每收到一个对新的报文段的确认后（一个传输轮次 transmission round），可以把拥塞窗口增加，一般是加倍，直到到达慢开始门限值ssthresh </p>
<p>一个传输轮次 (transmission round)，也即往返时间RTT。例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。</p>
<p>拥塞避免阶段：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就执行慢开始算法</p>
![image-20210310105641866](D:\blog\blog\source\_posts\ComputerNetwork5\14.png)

如上图，当拥塞窗口 cwnd = 24 时，网络出现了超时（图中的点2），发送方判断为网络拥塞。于是调整门限值 ssthresh = cwnd / 2 = 12，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。

快重传算法：发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不会误认为出现了网络拥塞。因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法。

因此，如上图点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值ssthresh = cwnd / 2 = 8，同时设置拥塞窗口cwnd = ssthresh = 8，并开始执行拥塞避免算法。


<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\15.png" alt="image-20210310110201209"></p>
<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\16.png" alt="image-20210310110525642"></p>

<h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><h3 id="运输连接"><a href="#运输连接" class="headerlink" title="运输连接"></a>运输连接</h3><p>TCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)，被动等待连接建立的应用进程叫做服务器(server)。</p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\17.png" alt="image-20210310110927241"></p>
<p>三次握手：</p>
<p>A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</p>
<p>B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x +1，自己选择的序号 seq = y。</p>
<p>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。A 的 TCP 通知上层应用进程，连接已经建立。B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程TCP 连接已经建立。</p>
<h3 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h3><p>四报文握手</p>

<p><img src="/03/10/ComputerNetwork5/blog\blog\source\_posts\ComputerNetwork5\18.png" alt="image-20210310111200242"></p>
<p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。</p>
<p>B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。</p>
<p>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ComputerNetwork/" rel="tag"><i class="fa fa-tag"></i> ComputerNetwork</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/08/ComputerNetwork4/" rel="next" title="网络层">
                <i class="fa fa-chevron-left"></i> 网络层
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/NaNillll" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#运输层的两个主要协议"><span class="nav-number">1.</span> <span class="nav-text">运输层的两个主要协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP-运输层端口"><span class="nav-number">2.</span> <span class="nav-text">TCP&#x2F;IP 运输层端口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP"><span class="nav-number">3.</span> <span class="nav-text">UDP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-number">4.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可靠传输的工作原理"><span class="nav-number">5.</span> <span class="nav-text">可靠传输的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#停止等待协议"><span class="nav-number">5.1.</span> <span class="nav-text">停止等待协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#无差错情况"><span class="nav-number">5.1.1.</span> <span class="nav-text">无差错情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#出现差错"><span class="nav-number">5.1.2.</span> <span class="nav-text">出现差错</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动重传请求-ARQ"><span class="nav-number">5.2.</span> <span class="nav-text">自动重传请求 ARQ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流水线传输"><span class="nav-number">5.3.</span> <span class="nav-text">流水线传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连续-ARQ-协议"><span class="nav-number">5.4.</span> <span class="nav-text">连续 ARQ 协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP报文"><span class="nav-number">6.</span> <span class="nav-text">TCP报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-可靠传输的实现"><span class="nav-number">7.</span> <span class="nav-text">TCP 可靠传输的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#超时重传时间的选择"><span class="nav-number">7.1.</span> <span class="nav-text">超时重传时间的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择确认-SACK"><span class="nav-number">7.2.</span> <span class="nav-text">选择确认 SACK</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用滑动窗口实现流量控制"><span class="nav-number">8.</span> <span class="nav-text">利用滑动窗口实现流量控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发送与接受方的传输策略"><span class="nav-number">9.</span> <span class="nav-text">发送与接受方的传输策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-的拥塞控制"><span class="nav-number">10.</span> <span class="nav-text">TCP 的拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#拥塞控制与流量控制"><span class="nav-number">10.1.</span> <span class="nav-text">拥塞控制与流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开环控制和闭环控制"><span class="nav-number">10.2.</span> <span class="nav-text">开环控制和闭环控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥塞的指标"><span class="nav-number">10.3.</span> <span class="nav-text">拥塞的指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-的拥塞控制方法"><span class="nav-number">10.4.</span> <span class="nav-text">TCP 的拥塞控制方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断拥塞"><span class="nav-number">10.5.</span> <span class="nav-text">判断拥塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP拥塞控制算法"><span class="nav-number">10.6.</span> <span class="nav-text">TCP拥塞控制算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-的运输连接管理"><span class="nav-number">11.</span> <span class="nav-text">TCP 的运输连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运输连接"><span class="nav-number">11.1.</span> <span class="nav-text">运输连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接释放"><span class="nav-number">11.2.</span> <span class="nav-text">连接释放</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
  
 
  
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">42.9k</span>
  
</div>











        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
